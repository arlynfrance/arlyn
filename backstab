-- Full LocalScript: GUI (matches screenshot) + fixed slider + robust ESP (box, tracer, name, health, distance, team-check) + Backstab (Quad tween)
-- Paste into a LocalScript under StarterPlayerScripts

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local lp = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- === Core backstab vars (behavior preserved) ===
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 7.2
local mode = "Behind"
local daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

-- restore saved range attribute if present
if lp:GetAttribute("BackstabRange") then
	local attr = lp:GetAttribute("BackstabRange")
	if type(attr) == "number" then range = attr end
end

-- === GUI colors / style ===
local BG = Color3.fromRGB(40,40,42)
local PANEL = Color3.fromRGB(60,60,70)
local ACCENT = Color3.fromRGB(160,170,200)
local TEXT = Color3.fromRGB(230,230,230)

-- === Build ScreenGui + Main window ===
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BackstabHubV3"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")
screenGui.Enabled = true

local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0,520,0,320)
main.Position = UDim2.new(0,20,0,20)
main.BackgroundColor3 = BG
main.BorderColor3 = PANEL
main.BorderSizePixel = 3
main.Parent = screenGui

-- title bar
local title = Instance.new("Frame", main)
title.Name = "Title"
title.Size = UDim2.new(1,0,0,30)
title.BackgroundColor3 = PANEL
title.BorderSizePixel = 0

local titleLabel = Instance.new("TextLabel", title)
titleLabel.Size = UDim2.new(1,-12,1,0)
titleLabel.Position = UDim2.new(0,6,0,0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MOCKS' BACKSTAB HUB V3"
titleLabel.TextColor3 = TEXT
titleLabel.Font = Enum.Font.Code
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Left

-- divider under title
local divider = Instance.new("Frame", main)
divider.Size = UDim2.new(1,0,0,6)
divider.Position = UDim2.new(0,0,0,30)
divider.BackgroundColor3 = PANEL
divider.BorderSizePixel = 0

-- left column + right panel
local leftCol = Instance.new("Frame", main)
leftCol.Name = "Left"
leftCol.Size = UDim2.new(0,170,1,-36)
leftCol.Position = UDim2.new(0,6,0,36)
leftCol.BackgroundTransparency = 1

local rightPanel = Instance.new("Frame", main)
rightPanel.Name = "Right"
rightPanel.Size = UDim2.new(1,-188,1,-36)
rightPanel.Position = UDim2.new(0,182,0,36)
rightPanel.BackgroundColor3 = BG
rightPanel.BorderColor3 = PANEL
rightPanel.BorderSizePixel = 0

-- left background visual
local leftBg = Instance.new("Frame", main)
leftBg.Size = UDim2.new(0,164,1,-36)
leftBg.Position = UDim2.new(0,3,0,36)
leftBg.BackgroundColor3 = BG
leftBg.BorderColor3 = PANEL
leftBg.BorderSizePixel = 0
leftBg.ZIndex = main.ZIndex - 1

-- small factory function for left buttons
local function makeLeftButton(y, text)
	local b = Instance.new("TextButton")
	b.Size = UDim2.new(1,-6,0,30)
	b.Position = UDim2.new(0,3,0,y)
	b.BackgroundColor3 = PANEL
	b.TextColor3 = TEXT
	b.Font = Enum.Font.Code
	b.TextSize = 16
	b.Text = text
	b.Parent = leftCol
	local stroke = Instance.new("UIStroke", b)
	stroke.Color = Color3.fromRGB(80,80,90)
	stroke.Thickness = 1
	return b
end

-- backstab button
local backstabBtn = makeLeftButton(4, "backstab: off")

-- range label (panel style)
local rangeLabel = Instance.new("TextLabel", leftCol)
rangeLabel.Size = UDim2.new(1,-6,0,26)
rangeLabel.Position = UDim2.new(0,3,0,40)
rangeLabel.BackgroundColor3 = PANEL
rangeLabel.TextColor3 = TEXT
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.Text = "range: " .. tostring(range)
local rsStroke = Instance.new("UIStroke", rangeLabel)
rsStroke.Color = Color3.fromRGB(80,80,90)

-- slider frame
local sliderFrame = Instance.new("Frame", leftCol)
sliderFrame.Size = UDim2.new(1,-12,0,16)
sliderFrame.Position = UDim2.new(0,6,0,70)
sliderFrame.BackgroundColor3 = Color3.fromRGB(100,100,110)
sliderFrame.BorderSizePixel = 0
local sliderStroke = Instance.new("UIStroke", sliderFrame)
sliderStroke.Color = Color3.fromRGB(80,80,90)

local sliderFill = Instance.new("Frame", sliderFrame)
sliderFill.Size = UDim2.new((range - 1) / 9,0,1,0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = ACCENT
sliderFill.BorderSizePixel = 0

-- knob: centered anchorpoint (this fixes the alignment problem)
local knobSizePx = 12
local sliderKnob = Instance.new("Frame", sliderFrame)
sliderKnob.Name = "Knob"
sliderKnob.Size = UDim2.new(0, knobSizePx, 0, knobSizePx)
sliderKnob.AnchorPoint = Vector2.new(0.5,0.5)        -- IMPORTANT: center anchor
sliderKnob.Position = UDim2.new((range - 1) / 9, 0, 0.5, 0) -- centered vertically
sliderKnob.BackgroundColor3 = ACCENT
local knobCorner = Instance.new("UICorner", sliderKnob)
knobCorner.CornerRadius = UDim.new(0,4)

-- mode button
local modeBtn = makeLeftButton(98, "mode:" .. string.lower(mode))

-- ESP button on right panel like screenshot
local espBtn = Instance.new("TextButton", rightPanel)
espBtn.Size = UDim2.new(0,120,0,30)
espBtn.Position = UDim2.new(0,8,0,8)
espBtn.BackgroundColor3 = PANEL
espBtn.Text = "esp: off"
espBtn.TextColor3 = TEXT
espBtn.Font = Enum.Font.Code
espBtn.TextSize = 16
local espStroke = Instance.new("UIStroke", espBtn)
espStroke.Color = Color3.fromRGB(80,80,90)

-- === draggable title (robust) ===
main.Active = true
local dragging = false
local dragStartPos = Vector2.new()
local mainStartPos = UDim2.new()
title.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStartPos = i.Position
		mainStartPos = main.Position
		i.Changed:Connect(function()
			if i.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)
UserInputService.InputChanged:Connect(function(i)
	if dragging and i.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = i.Position - dragStartPos
		main.Position = UDim2.new(mainStartPos.X.Scale, mainStartPos.X.Offset + delta.X, mainStartPos.Y.Scale, mainStartPos.Y.Offset + delta.Y)
	end
end)

-- RightShift toggle
UserInputService.InputBegan:Connect(function(inp, gp)
	if gp then return end
	if inp.KeyCode == Enum.KeyCode.RightShift then
		screenGui.Enabled = not screenGui.Enabled
	end
end)

-- === slider behavior: 1.0 -> 10.0 with 0.1 step ===
local sliding = false
local function setRangeFromRel(rel)
	rel = math.clamp(rel, 0, 1)
	range = math.floor((1 + rel * 9) * 10 + 0.5) / 10 -- round nearest 0.1
	sliderFill.Size = UDim2.new(rel,0,1,0)
	sliderKnob.Position = UDim2.new(rel, 0, 0.5, 0)
	rangeLabel.Text = "range: " .. tostring(range)
	pcall(function() lp:SetAttribute("BackstabRange", range) end)
end

sliderKnob.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then sliding = true end
end)
sliderKnob.InputEnded:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then sliding = false end
end)
sliderFrame.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		local relX = math.clamp((i.Position.X - sliderFrame.AbsolutePosition.X) / sliderFrame.AbsoluteSize.X, 0, 1)
		setRangeFromRel(relX)
	end
end)
UserInputService.InputChanged:Connect(function(i)
	if sliding and i.UserInputType == Enum.UserInputType.MouseMovement then
		local relX = math.clamp((i.Position.X - sliderFrame.AbsolutePosition.X) / sliderFrame.AbsoluteSize.X, 0, 1)
		setRangeFromRel(relX)
	end
end)

-- initialize visuals
setRangeFromRel((range - 1) / 9)

-- === button bindings for backstab & mode ===
backstabBtn.MouseButton1Click:Connect(function()
	enabled = not enabled
	backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
	backstabBtn.BackgroundColor3 = (enabled and ACCENT) or PANEL
end)

modeBtn.MouseButton1Click:Connect(function()
	mode = (mode == "Behind") and "Around" or "Behind"
	modeBtn.Text = "mode:" .. string.lower(mode)
end)

-- === ESP Implementation (self-contained) ===
-- Features: Highlight outline, BillboardGui (name, health, distance), 2D bounding box, tracer line, team-check
local espEnabled = false
local espState = {
	players = {}, -- [player] = { highlight, billboard, boxParts, tracer, updateConn, charConn }
	playerAddedConn = nil
}

-- team-check default off; set to true if you want friendly filtering
local ESP_TEAM_CHECK = false

local function makeESPForPlayer(plr)
	if not plr or plr == lp then return end
	if espState.players[plr] then return end
	if not plr.Character then return end
	local char = plr.Character
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hrp or not hum then return end

	-- Highlight (3D)
	local highlight = Instance.new("Highlight")
	highlight.Adornee = char
	highlight.FillTransparency = 0.8
	highlight.OutlineTransparency = 0
	highlight.OutlineColor = (plr.Team and lp.Team and plr.Team == lp.Team) and Color3.fromRGB(120,120,120) or Color3.fromRGB(255,255,255)
	highlight.Parent = Workspace -- place in workspace to render properly

	-- Billboard (name, health, dist)
	local bill = Instance.new("BillboardGui")
	bill.Adornee = hrp
	bill.Size = UDim2.new(0,160,0,56)
	bill.StudsOffset = Vector3.new(0,2.25,0)
	bill.AlwaysOnTop = true
	bill.Parent = screenGui

	local frame = Instance.new("Frame", bill)
	frame.Size = UDim2.new(1,0,1,0)
	frame.BackgroundTransparency = 1

	local nameLabel = Instance.new("TextLabel", frame)
	nameLabel.Size = UDim2.new(1,0,0,18)
	nameLabel.Position = UDim2.new(0,0,0,0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.Code
	nameLabel.TextSize = 14
	nameLabel.TextColor3 = Color3.new(1,1,1)
	nameLabel.Text = plr.Name

	local healthOuter = Instance.new("Frame", frame)
	healthOuter.Size = UDim2.new(1,-10,0,8)
	healthOuter.Position = UDim2.new(0,5,0,20)
	healthOuter.BackgroundColor3 = Color3.fromRGB(30,30,30)
	healthOuter.BorderSizePixel = 0

	local healthBar = Instance.new("Frame", healthOuter)
	healthBar.Size = UDim2.new(1,0,1,0)
	healthBar.BackgroundColor3 = Color3.fromRGB(0,200,100)
	healthBar.BorderSizePixel = 0

	local distLabel = Instance.new("TextLabel", frame)
	distLabel.Size = UDim2.new(1,0,0,14)
	distLabel.Position = UDim2.new(0,0,0,30)
	distLabel.BackgroundTransparency = 1
	distLabel.Font = Enum.Font.Code
	distLabel.TextSize = 12
	distLabel.TextColor3 = Color3.new(1,1,1)
	distLabel.Text = ""

	-- 2D bounding box frames (top, left, right, bottom)
	local boxTop = Instance.new("Frame", screenGui)
	boxTop.BackgroundColor3 = ACCENT
	boxTop.Size = UDim2.new(0,0,0,2)
	boxTop.BorderSizePixel = 0
	boxTop.Visible = true

	local boxBottom = Instance.new("Frame", screenGui)
	boxBottom.BackgroundColor3 = ACCENT
	boxBottom.Size = UDim2.new(0,0,0,2)
	boxBottom.BorderSizePixel = 0

	local boxLeft = Instance.new("Frame", screenGui)
	boxLeft.BackgroundColor3 = ACCENT
	boxLeft.Size = UDim2.new(0,2,0,0)

	local boxRight = Instance.new("Frame", screenGui)
	boxRight.BackgroundColor3 = ACCENT
	boxRight.Size = UDim2.new(0,2,0,0)

	-- tracer (thin frame rotated)
	local tracer = Instance.new("Frame", screenGui)
	tracer.BackgroundColor3 = ACCENT
	tracer.BorderSizePixel = 0
	tracer.AnchorPoint = Vector2.new(0.5, 1) -- anchor at bottom center
	tracer.Size = UDim2.new(0,2,0,0) -- height updated live
	tracer.Visible = true

	-- update closure
	local conn = RunService.RenderStepped:Connect(function()
		if not espEnabled then return end
		if not plr.Parent or not plr.Character then return end
		local ch = plr.Character
		local h = ch:FindFirstChild("Humanoid")
		local hroot = ch:FindFirstChild("HumanoidRootPart") or ch:FindFirstChild("Torso") or ch:FindFirstChild("UpperTorso")
		local head = ch:FindFirstChild("Head")
		if not hroot or not head then
			-- hide visuals until character valid
			boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = false
			tracer.Visible = false
			bill.Enabled = false
			highlight.Enabled = false
			return
		end

		-- Team check
		if ESP_TEAM_CHECK and plr.Team and lp.Team and plr.Team == lp.Team then
			-- hide if same team
			boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = false
			tracer.Visible = false
			bill.Enabled = false
			highlight.Enabled = false
			return
		end

		highlight.Enabled = true
		bill.Enabled = true

		-- update health bar
		if h then
			local pct = math.clamp(h.Health / math.max(h.MaxHealth, 1), 0, 1)
			healthBar.Size = UDim2.new(pct, 0, 1, 0)
		end

		-- compute 2D box projection using head and root
		local headPos = head.Position
		local rootPos = hroot.Position
		local headScreen, headOn = camera:WorldToViewportPoint(headPos)
		local rootScreen, rootOn = camera:WorldToViewportPoint(rootPos)

		-- if either is behind camera, hide
		if not headOn and not rootOn then
			boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = false
			tracer.Visible = false
			bill.Enabled = false
			highlight.Enabled = false
			return
		end

		-- viewport coordinates (pixels)
		local hx, hy = headScreen.X, headScreen.Y
		local rx, ry = rootScreen.X, rootScreen.Y

		-- box center & height estimate
		local boxHeight = math.max(20, math.abs(ry - hy))
		local boxWidth = math.max(12, boxHeight * 0.5)

		local centerX = (hx + rx) / 2
		local topY = math.min(hy, ry) - math.max(8, boxHeight * 0.15)
		local bottomY = math.max(hy, ry) + math.max(8, boxHeight * 0.05)

		local leftX = centerX - boxWidth/2
		local rightX = centerX + boxWidth/2
		local height = math.max(12, bottomY - topY)

		-- set box frames (position in pixels)
		boxTop.Position = UDim2.new(0, leftX, 0, topY)
		boxTop.Size = UDim2.new(0, (rightX - leftX), 0, 2)

		boxBottom.Position = UDim2.new(0, leftX, 0, bottomY - 2)
		boxBottom.Size = UDim2.new(0, (rightX - leftX), 0, 2)

		boxLeft.Position = UDim2.new(0, leftX, 0, topY)
		boxLeft.Size = UDim2.new(0, 2, 0, height)

		boxRight.Position = UDim2.new(0, rightX - 2, 0, topY)
		boxRight.Size = UDim2.new(0, 2, 0, height)

		boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = true

		-- update billboard content (distance)
		local myHrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
		if myHrp and hroot then
			local d = (hroot.Position - myHrp.Position).Magnitude
			distLabel.Text = string.format("%.1fm", d)
		end

		-- tracer: draw from bottom-center of screen to target center (centerX, bottomY)
		local viewport = camera.ViewportSize
		local sx, sy = viewport.X * 0.5, viewport.Y - 8
		local tx, ty = centerX, topY + height * 0.5
		local dx, dy = tx - sx, ty - sy
		local length = math.sqrt(dx*dx + dy*dy)
		-- position tracer at (sx, sy) with height length, rotated to angle
		if length > 2 then
			tracer.Visible = true
			local angle = math.deg(math.atan2(dy, dx)) - 90 -- frame rotation offset
			tracer.Size = UDim2.new(0, 2, 0, length)
			tracer.Position = UDim2.new(0, sx, 0, sy)
			tracer.AnchorPoint = Vector2.new(0.5, 1)
			tracer.Rotation = angle
		else
			tracer.Visible = false
		end
	end)

	-- store and return
	espState.players[plr] = {
		highlight = highlight,
		bill = bill,
		boxTop = boxTop,
		boxBottom = boxBottom,
		boxLeft = boxLeft,
		boxRight = boxRight,
		tracer = tracer,
		conn = conn
	}
end

local function removeESPForPlayer(plr)
	local data = espState.players[plr]
	if not data then return end
	pcall(function()
		if data.conn and data.conn.Disconnect then data.conn:Disconnect() end
		if data.highlight and data.highlight.Parent then data.highlight:Destroy() end
		if data.bill and data.bill.Parent then data.bill:Destroy() end
		if data.boxTop and data.boxTop.Parent then data.boxTop:Destroy() end
		if data.boxBottom and data.boxBottom.Parent then data.boxBottom:Destroy() end
		if data.boxLeft and data.boxLeft.Parent then data.boxLeft:Destroy() end
		if data.boxRight and data.boxRight.Parent then data.boxRight:Destroy() end
		if data.tracer and data.tracer.Parent then data.tracer:Destroy() end
	end)
	espState.players[plr] = nil
end

local function enableESP()
	if espEnabled then return end
	espEnabled = true
	-- create for current players
	for _,p in ipairs(Players:GetPlayers()) do
		if p ~= lp and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			makeESPForPlayer(p)
		end
		-- character added handling
		p.CharacterAdded:Connect(function(char)
			-- small wait for hrp
			task.wait(0.05)
			if espEnabled and p ~= lp and char:FindFirstChild("HumanoidRootPart") then
				removeESPForPlayer(p)
				makeESPForPlayer(p)
			end
		end)
	end
	-- player added
	if not espState.playerAddedConn then
		espState.playerAddedConn = Players.PlayerAdded:Connect(function(plr)
			plr.CharacterAdded:Connect(function(char)
				task.wait(0.05)
				if espEnabled and plr ~= lp and char:FindFirstChild("HumanoidRootPart") then
					makeESPForPlayer(plr)
				end
			end)
		end)
	end
end

local function disableESP()
	if not espEnabled then return end
	espEnabled = false
	-- disconnect player added conn
	if espState.playerAddedConn then
		espState.playerAddedConn:Disconnect()
		espState.playerAddedConn = nil
	end
	-- remove all player visuals
	for plr, _ in pairs(espState.players) do
		removeESPForPlayer(plr)
	end
	espState.players = {}
end

espBtn.MouseButton1Click:Connect(function()
	if not espEnabled then
		espBtn.Text = "esp: on"
		espBtn.BackgroundColor3 = ACCENT
		enableESP()
	else
		espBtn.Text = "esp: off"
		espBtn.BackgroundColor3 = PANEL
		disableESP()
	end
end)

-- cleanup safety
local function cleanupAll()
	disableESP()
end

-- === helper: isBehindTarget (keeps your logic) ===
local function isBehindTarget(hrp, targetHRP)
	local distance = (hrp.Position - targetHRP.Position).Magnitude
	if distance > range then return false end
	if mode == "Around" then return true end
	local direction = -targetHRP.CFrame.LookVector
	local toPlayer = (hrp.Position - targetHRP.Position)
	return toPlayer:Dot(direction) > 0.5
end

-- === Main backstab loop (unchanged behavior; uses Quad tween) ===
RunService.Heartbeat:Connect(function()
	if not enabled or cooldown then return end
	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
	local hrp = char.HumanoidRootPart

	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			local kHRP = killer.HumanoidRootPart
			if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
				cooldown = true
				lastTarget = killer
				local start = tick()
				local didDagger = false
				local connection
				connection = RunService.Heartbeat:Connect(function()
					if not (char and char.Parent and kHRP and kHRP.Parent) then
						if connection then connection:Disconnect() end
						return
					end
					local elapsed = tick() - start
					if elapsed >= 0.5 then
						if connection then connection:Disconnect() end
						return
					end
					-- tween behind target (Quad easing preserved)
					local behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 0.3)
					local targetCFrame = CFrame.new(behindPos, behindPos + kHRP.CFrame.LookVector)
					local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
					local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
					tween:Play()
					-- align look + dagger once
					if not didDagger then
						didDagger = true
						local faceStart = tick()
						local faceConn
						faceConn = RunService.Heartbeat:Connect(function()
							if tick() - faceStart >= 0.7 or not kHRP or not kHRP.Parent then
								if faceConn then faceConn:Disconnect() end
								return
							end
							hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + kHRP.CFrame.LookVector)
						end)
						pcall(function() daggerRemote:FireServer("UseActorAbility", "Dagger") end)
					end
				end)
				task.delay(2, function()
					RunService.Heartbeat:Wait()
					while isBehindTarget(hrp, kHRP) do
						RunService.Heartbeat:Wait()
					end
					lastTarget = nil
					cooldown = false
				end)
				break
			end
		end
	end
end)

-- End of script

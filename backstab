-- Backstab Playground â€” Exunys-style ESP integrated + GUI + Tween-then-stab
-- Paste into StarterPlayerScripts

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local camera = workspace.CurrentCamera

local lp = Players.LocalPlayer

-- ====== CONFIG / STATE ======
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 4.0
local mode = "behind"

-- dagger remote (wrapped)
local daggerRemote
pcall(function()
    daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

-- Killer list for coloring
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killerSet = {}
for _, n in ipairs(killerNames) do killerSet[n] = true end

-- ESP settings (persist in session)
getgenv().ESP_SETTINGS = getgenv().ESP_SETTINGS or {
    boxes = false,
    filled = false,
    outline = false,
    names = false,
    distance = false,
    health = false,
    tracers = false,
    crosshair = false,
    keepOnDeath = true,
    updateRate = 0.033, -- seconds
}
local ESP = getgenv().ESP_SETTINGS

-- Visual constants
local WHITE = Color3.fromRGB(255,255,255)
local KILLER_COLOR = Color3.fromRGB(255,80,80)
local SURV_COLOR = Color3.fromRGB(230,230,230)

-- GUI colors / geometry (keeps your style)
local BG_COLOR = Color3.fromRGB(37,40,45)
local PANEL_COLOR = Color3.fromRGB(42,45,50)
local ACCENT_COLOR = Color3.fromRGB(56,63,76)
local BTN_OFF = Color3.fromRGB(95,95,100)
local BTN_ON  = Color3.fromRGB(120,120,140)
local SLIDER_COLOR = Color3.fromRGB(110,110,120)
local TITLE_COLOR = Color3.fromRGB(200,200,200)

local MAIN_W, MAIN_H = 540, 300
local MAIN_X, MAIN_Y = 10, 10
local OFF_Y = -350

-- Tuneables
local BOX_FILL_ALPHA = 0.85
local STROKE_THICKNESS = 1
local TRACER_THICKNESS = 2
local HEALTH_BAR_WIDTH = 6
local NAME_TEXT_SIZE = 16
local DIST_TEXT_SIZE = 14
local TRACER_ORIGIN_OFFSET = 36 -- pixels from bottom

-- ====== GUI BUILD (keeps layout, replaced ESP buttons) ======
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BackstabPlaygroundGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
mainFrame.Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
mainFrame.Visible = false

local outlineStroke = Instance.new("UIStroke", mainFrame)
outlineStroke.Color = ACCENT_COLOR
outlineStroke.Thickness = 3

local titleBar = Instance.new("Frame", mainFrame)
titleBar.Size = UDim2.new(1, 0, 0, 28)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundColor3 = Color3.fromRGB(60,60,67)
titleBar.BorderSizePixel = 0

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1, -12, 1, 0)
titleText.Position = UDim2.new(0, 6, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "BACKSTAB PLAYGROUND"
titleText.Font = Enum.Font.Code
titleText.TextSize = 14
titleText.TextColor3 = TITLE_COLOR
titleText.TextXAlignment = Enum.TextXAlignment.Left

local topDivider = Instance.new("Frame", mainFrame)
topDivider.Size = UDim2.new(1, -12, 0, 6)
topDivider.Position = UDim2.new(0, 6, 0, 28)
topDivider.BackgroundColor3 = ACCENT_COLOR
topDivider.BorderSizePixel = 0

local leftPanel = Instance.new("Frame", mainFrame)
leftPanel.Size = UDim2.new(0, 170, 1, -40)
leftPanel.Position = UDim2.new(0, 6, 0, 36)
leftPanel.BackgroundColor3 = PANEL_COLOR
leftPanel.BorderSizePixel = 0

local midSep = Instance.new("Frame", mainFrame)
midSep.Size = UDim2.new(0, 6, 1, -40)
midSep.Position = UDim2.new(0, 180, 0, 36)
midSep.BackgroundColor3 = ACCENT_COLOR
midSep.BorderSizePixel = 0

local rightPanel = Instance.new("Frame", mainFrame)
rightPanel.Size = UDim2.new(0, 170, 1, -40)
rightPanel.Position = UDim2.new(0, 192, 0, 36)
rightPanel.BackgroundColor3 = PANEL_COLOR
rightPanel.BorderSizePixel = 0

local innerTop = Instance.new("Frame", mainFrame)
innerTop.Size = UDim2.new(1, -12, 0, 6)
innerTop.Position = UDim2.new(0, 6, 0, 32)
innerTop.BackgroundColor3 = ACCENT_COLOR
innerTop.BorderSizePixel = 0

local function makeBtn(parent, posY, text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(0, 120, 0, 28)
    b.Position = UDim2.new(0, 8, 0, posY)
    b.BackgroundColor3 = BTN_OFF
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Code
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(20,20,20)
    b.Text = text
    b.AutoButtonColor = false
    b.Parent = parent
    return b
end

-- left controls
local backstabBtn = makeBtn(leftPanel, 8, "backstab: off")
local rangeLabel = Instance.new("TextLabel", leftPanel)
rangeLabel.Size = UDim2.new(0, 150, 0, 18)
rangeLabel.Position = UDim2.new(0, 8, 0, 42)
rangeLabel.BackgroundTransparency = 1
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.TextColor3 = TITLE_COLOR
rangeLabel.Text = ("range: %.1f"):format(range)
rangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local sliderBg = Instance.new("Frame", leftPanel)
sliderBg.Size = UDim2.new(0, 150, 0, 12)
sliderBg.Position = UDim2.new(0, 8, 0, 64)
sliderBg.BackgroundColor3 = Color3.fromRGB(60,60,65)
sliderBg.BorderSizePixel = 0

local sliderFill = Instance.new("Frame", sliderBg)
sliderFill.Size = UDim2.new((range - 1) / 9, 0, 1, 0)
sliderFill.BackgroundColor3 = SLIDER_COLOR
sliderFill.BorderSizePixel = 0

local sliderKnob = Instance.new("TextButton", sliderBg)
sliderKnob.Size = UDim2.new(0, 12, 0, 12)
sliderKnob.Position = UDim2.new((range - 1) / 9, -6, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(30,30,30)
sliderKnob.BorderSizePixel = 0
sliderKnob.AutoButtonColor = false
sliderKnob.Text = ""

local modeBtn = makeBtn(leftPanel, 92, ("mode:%s"):format(mode))

-- right controls (Exunys features toggles)
local boxesBtn = makeBtn(rightPanel, 8, ("boxes:%s"):format(ESP.boxes and "on" or "off"))
local filledBtn = makeBtn(rightPanel, 44, ("fill:%s"):format(ESP.filled and "on" or "off"))
local outlineBtn = makeBtn(rightPanel, 80, ("outline:%s"):format(ESP.outline and "on" or "off"))
local namesBtn = makeBtn(rightPanel, 116, ("names:%s"):format(ESP.names and "on" or "off"))
local distBtn = makeBtn(rightPanel, 152, ("distance:%s"):format(ESP.distance and "on" or "off"))
local healthBtn = makeBtn(rightPanel, 188, ("health:%s"):format(ESP.health and "on" or "off"))
local tracersBtn = makeBtn(rightPanel, 224, ("tracers:%s"):format(ESP.tracers and "on" or "off"))
local crossBtn = makeBtn(rightPanel, 260, ("crosshair:%s"):format(ESP.crosshair and "on" or "off"))

-- ====== GUI behavior ======
local guiVisible = false
local function slideIn()
    mainFrame.Visible = true
    TweenService:Create(mainFrame, TweenInfo.new(0.38, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, MAIN_X, 0, MAIN_Y)
    }):Play()
end
local function slideOut()
    local t = TweenService:Create(mainFrame, TweenInfo.new(0.30, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
    })
    t:Play()
    t.Completed:Connect(function()
        if not guiVisible then mainFrame.Visible = false end
    end)
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        guiVisible = not guiVisible
        if guiVisible then slideIn() else slideOut() end
    end
end)

-- slider logic
local dragging = false
local function setSliderFromX(x)
    local absPos = sliderBg.AbsolutePosition.X
    local absSize = sliderBg.AbsoluteSize.X
    local localX = math.clamp(x - absPos, 0, absSize)
    local pct = (absSize > 0) and (localX / absSize) or 0
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderKnob.Position = UDim2.new(pct, -6, 0, 0)
    range = 1 + pct * 9
    rangeLabel.Text = ("range: %.1f"):format(range)
    ESP.range = range
    getgenv().ESP_SETTINGS = ESP
end

sliderKnob.MouseButton1Down:Connect(function() dragging = true end)
UserInputService.InputChanged:Connect(function(inp)
    if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then setSliderFromX(inp.Position.X) end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

local function updateBtnVisual(btn, on)
    btn.BackgroundColor3 = on and BTN_ON or BTN_OFF
end

backstabBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
    updateBtnVisual(backstabBtn, enabled)
end)

modeBtn.MouseButton1Click:Connect(function()
    if mode == "behind" then mode = "around" else mode = "behind" end
    modeBtn.Text = "mode:" .. mode
    ESP.mode = mode
    getgenv().ESP_SETTINGS = ESP
end)

boxesBtn.MouseButton1Click:Connect(function()
    ESP.boxes = not ESP.boxes
    boxesBtn.Text = ("boxes:%s"):format(ESP.boxes and "on" or "off")
    updateBtnVisual(boxesBtn, ESP.boxes)
    getgenv().ESP_SETTINGS = ESP
end)
filledBtn.MouseButton1Click:Connect(function()
    ESP.filled = not ESP.filled
    filledBtn.Text = ("fill:%s"):format(ESP.filled and "on" or "off")
    updateBtnVisual(filledBtn, ESP.filled)
    getgenv().ESP_SETTINGS = ESP
end)
outlineBtn.MouseButton1Click:Connect(function()
    ESP.outline = not ESP.outline
    outlineBtn.Text = ("outline:%s"):format(ESP.outline and "on" or "off")
    updateBtnVisual(outlineBtn, ESP.outline)
    getgenv().ESP_SETTINGS = ESP
end)
namesBtn.MouseButton1Click:Connect(function()
    ESP.names = not ESP.names
    namesBtn.Text = ("names:%s"):format(ESP.names and "on" or "off")
    updateBtnVisual(namesBtn, ESP.names)
    getgenv().ESP_SETTINGS = ESP
end)
distBtn.MouseButton1Click:Connect(function()
    ESP.distance = not ESP.distance
    distBtn.Text = ("distance:%s"):format(ESP.distance and "on" or "off")
    updateBtnVisual(distBtn, ESP.distance)
    getgenv().ESP_SETTINGS = ESP
end)
healthBtn.MouseButton1Click:Connect(function()
    ESP.health = not ESP.health
    healthBtn.Text = ("health:%s"):format(ESP.health and "on" or "off")
    updateBtnVisual(healthBtn, ESP.health)
    getgenv().ESP_SETTINGS = ESP
end)
tracersBtn.MouseButton1Click:Connect(function()
    ESP.tracers = not ESP.tracers
    tracersBtn.Text = ("tracers:%s"):format(ESP.tracers and "on" or "off")
    updateBtnVisual(tracersBtn, ESP.tracers)
    getgenv().ESP_SETTINGS = ESP
end)
crossBtn.MouseButton1Click:Connect(function()
    ESP.crosshair = not ESP.crosshair
    crossBtn.Text = ("crosshair:%s"):format(ESP.crosshair and "on" or "off")
    updateBtnVisual(crossBtn, ESP.crosshair)
    getgenv().ESP_SETTINGS = ESP
end)

-- init visuals
updateBtnVisual(boxesBtn, ESP.boxes)
updateBtnVisual(filledBtn, ESP.filled)
updateBtnVisual(outlineBtn, ESP.outline)
updateBtnVisual(namesBtn, ESP.names)
updateBtnVisual(distBtn, ESP.distance)
updateBtnVisual(healthBtn, ESP.health)
updateBtnVisual(tracersBtn, ESP.tracers)
updateBtnVisual(crossBtn, ESP.crosshair)
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)
modeBtn.Text = "mode:" .. mode

-- ====== Overlay objects ======
local overlayFolder = Instance.new("Folder", screenGui)
overlayFolder.Name = "ESPOverlays"

local boxOverlays = {}
local nameLabels = {}
local distLabels = {}
local healthBars = {}
local tracerLines = {}
local crossGui = nil

-- creators
local function createBox(name)
    local con = Instance.new("Frame")
    con.Name = "Box_" .. name
    con.BackgroundTransparency = 1
    con.BorderSizePixel = 0
    con.Size = UDim2.new(0, 60, 0, 120)
    con.Parent = overlayFolder

    local fill = Instance.new("Frame", con)
    fill.Name = "Fill"
    fill.Size = UDim2.new(1,0,1,0)
    fill.Position = UDim2.new(0,0,0,0)
    fill.BackgroundColor3 = WHITE
    fill.BackgroundTransparency = 1 -- controlled by ESP.filled
    fill.BorderSizePixel = 0

    local border = Instance.new("Frame", con)
    border.Name = "Border"
    border.Size = UDim2.new(1,0,1,0)
    border.Position = UDim2.new(0,0,0,0)
    border.BackgroundTransparency = 1
    border.BorderSizePixel = 0

    local stroke = Instance.new("UIStroke", border)
    stroke.Color = WHITE
    stroke.Thickness = STROKE_THICKNESS
    stroke.Enabled = ESP.outline

    return con
end

local function createNameLabel(name)
    local lbl = Instance.new("TextLabel")
    lbl.Name = "Name_" .. name
    lbl.Size = UDim2.new(0,200,0,20)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Code
    lbl.TextSize = NAME_TEXT_SIZE
    lbl.TextColor3 = WHITE
    lbl.Text = name
    lbl.Parent = overlayFolder
    return lbl
end

local function createDistLabel(name)
    local lbl = Instance.new("TextLabel")
    lbl.Name = "Dist_" .. name
    lbl.Size = UDim2.new(0,80,0,16)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Code
    lbl.TextSize = DIST_TEXT_SIZE
    lbl.TextColor3 = WHITE
    lbl.Text = ""
    lbl.Parent = overlayFolder
    return lbl
end

local function createHealthBar(name)
    local bg = Instance.new("Frame")
    bg.Name = "HealthBG_" .. name
    bg.Size = UDim2.new(0, HEALTH_BAR_WIDTH, 0, 40)
    bg.BackgroundColor3 = Color3.fromRGB(25,25,25)
    bg.BorderSizePixel = 0
    bg.Parent = overlayFolder

    local fill = Instance.new("Frame", bg)
    fill.Name = "Fill"
    fill.Size = UDim2.new(1,0,1,0)
    fill.Position = UDim2.new(0,0,0,0)
    fill.BackgroundColor3 = WHITE
    fill.BorderSizePixel = 0
    return bg
end

local function createTracer(name)
    local t = Instance.new("Frame")
    t.Name = "Tracer_" .. name
    t.Size = UDim2.new(0, 0, 0, TRACER_THICKNESS)
    t.BackgroundColor3 = WHITE
    t.BorderSizePixel = 0
    t.AnchorPoint = Vector2.new(0, 0.5)
    t.Parent = overlayFolder
    return t
end

local function createCrosshair()
    -- small center crosshair using Frames
    local g = Instance.new("Folder", overlayFolder)
    g.Name = "Crosshair"
    local h = 10
    local v = Instance.new("Frame", g)
    v.Size = UDim2.new(0, 1, 0, h)
    v.Position = UDim2.new(0.5, -0.5, 0.5, -math.floor(h/2))
    v.BackgroundColor3 = WHITE
    v.BorderSizePixel = 0
    local hh = Instance.new("Frame", g)
    hh.Size = UDim2.new(0, h, 0, 1)
    hh.Position = UDim2.new(0.5, -math.floor(h/2), 0.5, -0.5)
    hh.BackgroundColor3 = WHITE
    hh.BorderSizePixel = 0
    return g
end

local function removeAllFor(name)
    if boxOverlays[name] and boxOverlays[name].Parent then boxOverlays[name]:Destroy() end; boxOverlays[name]=nil
    if nameLabels[name] and nameLabels[name].Parent then nameLabels[name]:Destroy() end; nameLabels[name]=nil
    if distLabels[name] and distLabels[name].Parent then distLabels[name]:Destroy() end; distLabels[name]=nil
    if healthBars[name] and healthBars[name].Parent then healthBars[name]:Destroy() end; healthBars[name]=nil
    if tracerLines[name] and tracerLines[name].Parent then tracerLines[name]:Destroy() end; tracerLines[name]=nil
end

Players.PlayerRemoving:Connect(function(plr) removeAllFor(plr.Name) end)

-- Utility
local function worldToScreen(vec3)
    local p, on = camera:WorldToViewportPoint(vec3)
    return Vector2.new(p.X, p.Y), on
end

local function projectBounds(rootPart)
    if not rootPart then return nil end
    local topWorld = rootPart.Position + Vector3.new(0, 2.4, 0)
    local botWorld = rootPart.Position + Vector3.new(0, -1.0, 0)
    local top2, topOn = worldToScreen(topWorld)
    local bot2, botOn = worldToScreen(botWorld)
    return top2, bot2, (topOn or botOn), topWorld, botWorld
end

local function getHealthPercent(char)
    if not char then return nil end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health and humanoid.MaxHealth and humanoid.MaxHealth > 0 then
        return math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
    end
    return nil
end

-- Tween-behind-and-stab
local function tweenBehindAndStab(targetHRP, duration)
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = lp.Character.HumanoidRootPart
    if not (targetHRP and targetHRP.Parent) then return end

    local behindOffset = 0.6
    local behindPos = targetHRP.Position - (targetHRP.CFrame.LookVector * behindOffset)
    local targetCFrame = CFrame.new(behindPos, behindPos + targetHRP.CFrame.LookVector)

    local ok, tween = pcall(function()
        return TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { CFrame = targetCFrame })
    end)
    if not ok or not tween then
        pcall(function()
            hrp.CFrame = targetCFrame
            if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end
        end)
        return
    end

    tween:Play()
    local conn
    conn = tween.Completed:Connect(function()
        if conn then conn:Disconnect() end
        if not (targetHRP and targetHRP.Parent) then return end
        if hrp and hrp.Parent then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + targetHRP.CFrame.LookVector) end
        pcall(function() if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end end)
    end)

    task.delay(duration + 0.1, function()
        if conn and conn.Connected then conn:Disconnect() end
    end)
end

-- Main loop (throttled by updateRate)
local accumulator = 0
RunService.RenderStepped:Connect(function(dt)
    accumulator = accumulator - dt
    if accumulator > 0 then return end
    accumulator = ESP.updateRate or 0.033

    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then
        -- cleanup all overlays
        for name,_ in pairs(boxOverlays) do removeAllFor(name) end
        if crossGui then crossGui.Parent = nil; crossGui = nil end
        return
    end
    local hrp = char.HumanoidRootPart

    -- draw crosshair if enabled
    if ESP.crosshair then
        if not crossGui then crossGui = createCrosshair() end
        crossGui.Parent = overlayFolder
    else
        if crossGui and crossGui.Parent then crossGui.Parent = nil end
    end

    -- iterate players
    for _, other in ipairs(Players:GetPlayers()) do
        if other ~= lp then
            local otherChar = other.Character
            local root = otherChar and (otherChar:FindFirstChild("HumanoidRootPart") or otherChar:FindFirstChild("Torso") or otherChar:FindFirstChild("UpperTorso"))
            if root or (ESP.keepOnDeath and otherChar) then
                local name = other.Name
                local isKiller = killerSet[name]
                local color = isKiller and KILLER_COLOR or WHITE

                -- BOXES
                if ESP.boxes then
                    if not boxOverlays[name] then
                        boxOverlays[name] = createBox(name)
                    end
                    local box = boxOverlays[name]
                    local top2, bot2, ons = projectBounds(root)
                    if ons and top2 and bot2 then
                        local height = math.max(18, math.abs(top2.Y - bot2.Y))
                        local width = math.max(10, math.floor(height * 0.45))
                        box.Size = UDim2.new(0, width, 0, height)
                        box.Position = UDim2.new(0, top2.X - (width/2), 0, top2.Y)
                        box.Visible = true
                        local fill = box:FindFirstChild("Fill")
                        if fill then
                            fill.BackgroundTransparency = ESP.filled and (1 - BOX_FILL_ALPHA) or 1
                            fill.BackgroundColor3 = color
                        end
                        local border = box:FindFirstChild("Border")
                        if border then
                            local stroke = border:FindFirstChildOfClass("UIStroke")
                            if stroke then
                                stroke.Color = color
                                stroke.Enabled = ESP.outline
                            end
                        end
                    else
                        box.Visible = false
                    end
                else
                    if boxOverlays[name] then boxOverlays[name]:Destroy(); boxOverlays[name] = nil end
                end

                -- NAMES + DISTANCE
                if ESP.names then
                    if not nameLabels[name] then nameLabels[name] = createNameLabel(name) end
                    local head = otherChar and otherChar:FindFirstChild("Head")
                    local posWorld = head and (head.Position + Vector3.new(0,0.5,0)) or (root and root.Position + Vector3.new(0,1.5,0))
                    if posWorld then
                        local pos2, on = worldToScreen(posWorld)
                        local lbl = nameLabels[name]
                        if on then
                            lbl.Position = UDim2.new(0, pos2.X - (lbl.AbsoluteSize.X/2), 0, pos2.Y - 24)
                            lbl.Visible = true
                            lbl.TextColor3 = color
                            lbl.Text = name
                        else
                            lbl.Visible = false
                        end
                    end
                else
                    if nameLabels[name] then nameLabels[name]:Destroy(); nameLabels[name] = nil end
                end

                if ESP.distance then
                    if not distLabels[name] then distLabels[name] = createDistLabel(name) end
                    local rootPos = root and root.Position
                    if rootPos then
                        local dist = math.floor((hrp.Position - rootPos).Magnitude)
                        local pos2, on = worldToScreen(rootPos + Vector3.new(0,1.5,0))
                        local dl = distLabels[name]
                        if on then
                            dl.Position = UDim2.new(0, pos2.X + 4, 0, pos2.Y - 12)
                            dl.Visible = true
                            dl.Text = tostring(dist) .. "m"
                            dl.TextColor3 = color
                        else
                            dl.Visible = false
                        end
                    end
                else
                    if distLabels[name] then distLabels[name]:Destroy(); distLabels[name] = nil end
                end

                -- HEALTH
                if ESP.health then
                    if not healthBars[name] then healthBars[name] = createHealthBar(name) end
                    local hb = healthBars[name]
                    local top2, bot2, ons = projectBounds(root)
                    if ons and top2 and bot2 then
                        local height = math.max(18, math.abs(top2.Y - bot2.Y))
                        hb.Size = UDim2.new(0, HEALTH_BAR_WIDTH, 0, height)
                        hb.Position = UDim2.new(0, top2.X - (math.floor((HEALTH_BAR_WIDTH/2) + (height*0.5))) - 12, 0, top2.Y)
                        hb.Visible = true
                        local fill = hb:FindFirstChild("Fill")
                        if fill then
                            local pct = getHealthPercent(otherChar) or 1
                            fill.Size = UDim2.new(1,0,pct,0)
                            fill.Position = UDim2.new(0,0,1-pct,0)
                            fill.BackgroundColor3 = color
                        end
                    else
                        hb.Visible = false
                    end
                else
                    if healthBars[name] then healthBars[name]:Destroy(); healthBars[name] = nil end
                end

                -- TRACERS
                if ESP.tracers then
                    if not tracerLines[name] then tracerLines[name] = createTracer(name) end
                    local tracer = tracerLines[name]
                    local headWorld = (otherChar and otherChar:FindFirstChild("Head") and otherChar.Head.Position) or (root and root.Position + Vector3.new(0,1.5,0))
                    if headWorld then
                        local head2, headOn = worldToScreen(headWorld)
                        local origin = Vector2.new(camera.ViewportSize.X * 0.5, camera.ViewportSize.Y - TRACER_ORIGIN_OFFSET)
                        local delta = head2 - origin
                        local dist = math.max(2, delta.Magnitude)
                        local angle = math.deg(math.atan2(delta.Y, delta.X))
                        tracer.Size = UDim2.new(0, math.floor(dist), 0, TRACER_THICKNESS)
                        tracer.Position = UDim2.new(0, origin.X, 0, origin.Y)
                        tracer.Rotation = angle
                        tracer.AnchorPoint = Vector2.new(0, 0.5)
                        tracer.BackgroundColor3 = color
                        tracer.Visible = headOn
                    end
                else
                    if tracerLines[name] then tracerLines[name].Visible = false end
                end
            else
                -- cleanup overlays for that player
                if boxOverlays[other.Name] or nameLabels[other.Name] or distLabels[other.Name] or healthBars[other.Name] or tracerLines[other.Name] then
                    removeAllFor(other.Name)
                end
            end
        end
    end

    -- Backstab detection / tween-to-stab
    local killersToCheck = {}
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, nm in ipairs(killerNames) do
            local k = killersFolder:FindFirstChild(nm)
            if k and k:FindFirstChild("HumanoidRootPart") then table.insert(killersToCheck, k) end
        end
    end
    if #killersToCheck == 0 then
        for _, other in ipairs(Players:GetPlayers()) do
            if other ~= lp and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(killersToCheck, other.Character)
            end
        end
    end

    for _, kobj in ipairs(killersToCheck) do
        local kHRP = kobj and kobj:FindFirstChild("HumanoidRootPart")
        if kHRP then
            if enabled and not cooldown and isBehindTarget(hrp, kHRP) and kobj ~= lastTarget then
                cooldown = true
                lastTarget = kobj

                tweenBehindAndStab(kHRP, 0.20)

                task.delay(2, function()
                    RunService.Heartbeat:Wait()
                    while isBehindTarget(hrp, kHRP) do RunService.Heartbeat:Wait() end
                    lastTarget = nil
                    cooldown = false
                end)
                break
            end
        end
    end
end)

-- Persist GUI labels & visuals
boxesBtn.Text = ("boxes:%s"):format(ESP.boxes and "on" or "off")
filledBtn.Text = ("fill:%s"):format(ESP.filled and "on" or "off")
outlineBtn.Text = ("outline:%s"):format(ESP.outline and "on" or "off")
namesBtn.Text = ("names:%s"):format(ESP.names and "on" or "off")
distBtn.Text = ("distance:%s"):format(ESP.distance and "on" or "off")
healthBtn.Text = ("health:%s"):format(ESP.health and "on" or "off")
tracersBtn.Text = ("tracers:%s"):format(ESP.tracers and "on" or "off")
crossBtn.Text = ("crosshair:%s"):format(ESP.crosshair and "on" or "off")
updateBtnVisual = updateBtnVisual or function(btn,on) btn.BackgroundColor3 = on and BTN_ON or BTN_OFF end
updateBtnVisual(boxesBtn, ESP.boxes)
updateBtnVisual(filledBtn, ESP.filled)
updateBtnVisual(outlineBtn, ESP.outline)
updateBtnVisual(namesBtn, ESP.names)
updateBtnVisual(distBtn, ESP.distance)
updateBtnVisual(healthBtn, ESP.health)
updateBtnVisual(tracersBtn, ESP.tracers)
updateBtnVisual(crossBtn, ESP.crosshair)
updateBtnVisual(backstabBtn, enabled)
getgenv().ESP_SETTINGS = ESP

-- keep original isBehindTarget logic
function isBehindTarget(hrp, targetHRP)
    local dist = (hrp.Position - targetHRP.Position).Magnitude
    if dist > range then return false end
    if mode == "around" then return true end
    local direction = -targetHRP.CFrame.LookVector
    local toPlayer = (hrp.Position - targetHRP.Position)
    return toPlayer:Dot(direction) > 0.5
end

-- End of script

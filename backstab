--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

--// Vars
local range = 4
local enabled = false
local cooldown = false
local lastTarget = nil
local mode = "Behind"
local daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

--// GUI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = lp:WaitForChild("PlayerGui")

-- Backstab Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 150, 0, 40)
toggleButton.Position = UDim2.new(0, 10, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 20
toggleButton.Text = "Backstab: OFF"
toggleButton.Parent = screenGui

toggleButton.MouseButton1Click:Connect(function()
	enabled = not enabled
	toggleButton.Text = "Backstab: " .. (enabled and "ON" or "OFF")
	toggleButton.BackgroundColor3 = enabled and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(30, 30, 30)
end)

-- Mode Toggle
local modeButton = Instance.new("TextButton")
modeButton.Size = UDim2.new(0, 150, 0, 25)
modeButton.Position = UDim2.new(0, 10, 0, 55)
modeButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
modeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
modeButton.Font = Enum.Font.SourceSans
modeButton.TextSize = 16
modeButton.Text = "Mode: Behind"
modeButton.Parent = screenGui

modeButton.MouseButton1Click:Connect(function()
	mode = (mode == "Behind") and "Around" or "Behind"
	modeButton.Text = "Mode: " .. mode
end)

-- Slider for range
local sliderBack = Instance.new("Frame", screenGui)
sliderBack.Size = UDim2.new(0, 240, 0, 14)
sliderBack.Position = UDim2.new(0, 10, 0, 90)
sliderBack.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
sliderBack.BorderSizePixel = 0
local sliderCorner = Instance.new("UICorner", sliderBack)
sliderCorner.CornerRadius = UDim.new(0, 6)

local sliderFill = Instance.new("Frame", sliderBack)
sliderFill.Size = UDim2.new((range - 1) / 9, 0, 1, 0)
sliderFill.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
local fillCorner = Instance.new("UICorner", sliderFill)
fillCorner.CornerRadius = UDim.new(0, 6)

local knob = Instance.new("ImageButton", sliderBack)
knob.Size = UDim2.new(0, 20, 0, 20)
knob.AnchorPoint = Vector2.new(0.5, 0.5)
knob.Position = UDim2.new((range - 1) / 9, 0, 0.5, 0)
knob.BackgroundColor3 = Color3.fromRGB(150, 0, 255)
knob.AutoButtonColor = false
local knobCorner = Instance.new("UICorner", knob)
knobCorner.CornerRadius = UDim.new(0, 10)

local function updateSlider(val)
	range = math.clamp(val, 1, 10)
	sliderFill.Size = UDim2.new((range - 1) / 9, 0, 1, 0)
	knob.Position = UDim2.new((range - 1) / 9, 0, 0.5, 0)
end

knob.MouseButton1Down:Connect(function()
	local uis = game:GetService("UserInputService")
	local moveConn, releaseConn
	moveConn = uis.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement then
			local rel = math.clamp((input.Position.X - sliderBack.AbsolutePosition.X) / sliderBack.AbsoluteSize.X, 0, 1)
			updateSlider(math.floor(rel * 9) + 1)
		end
	end)
	releaseConn = uis.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			moveConn:Disconnect()
			releaseConn:Disconnect()
		end
	end)
end)

-- ESP Vars
local espEnabled = false
local espFolder = Instance.new("Folder")
espFolder.Name = "ESP_Objects"
espFolder.Parent = workspace

local function createESP(part)
	local highlight = Instance.new("Highlight")
	highlight.FillTransparency = 1
	highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
	highlight.OutlineTransparency = 0
	highlight.Adornee = part
	highlight.Parent = espFolder
end

local function refreshESP()
	espFolder:ClearAllChildren()
	if not espEnabled then return end
	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			createESP(killer.HumanoidRootPart)
		end
	end
end

local espButton = Instance.new("TextButton")
espButton.Size = UDim2.new(0, 150, 0, 40)
espButton.Position = UDim2.new(0, 170, 0, 10)
espButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
espButton.TextColor3 = Color3.fromRGB(255, 255, 255)
espButton.Font = Enum.Font.SourceSansBold
espButton.TextSize = 20
espButton.Text = "ESP: OFF"
espButton.Parent = screenGui

espButton.MouseButton1Click:Connect(function()
	espEnabled = not espEnabled
	espButton.Text = "ESP: " .. (espEnabled and "ON" or "OFF")
	espButton.BackgroundColor3 = espEnabled and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(30, 30, 30)
	refreshESP()
end)

RunService.Heartbeat:Connect(function()
	if espEnabled then
		refreshESP()
	end
end)

-- Helper
local function isBehindTarget(hrp, targetHRP)
	local distance = (hrp.Position - targetHRP.Position).Magnitude
	if distance > range then return false end
	if mode == "Around" then return true end
	local direction = -targetHRP.CFrame.LookVector
	local toPlayer = (hrp.Position - targetHRP.Position)
	return toPlayer:Dot(direction) > 0.5
end

-- Main Backstab Logic
RunService.Heartbeat:Connect(function()
	if not enabled or cooldown then return end
	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
	local hrp = char.HumanoidRootPart

	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			local kHRP = killer.HumanoidRootPart
			if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
				cooldown = true
				lastTarget = killer
				local start = tick()
				local connection
				connection = RunService.Heartbeat:Connect(function()
					if not (char and char.Parent and kHRP and kHRP.Parent) then
						if connection then connection:Disconnect() end
						return
					end
					if tick() - start >= 0.5 then
						if connection then connection:Disconnect() end
						return
					end
					local behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 0.3)
					hrp.CFrame = CFrame.new(behindPos, behindPos + kHRP.CFrame.LookVector)
					daggerRemote:FireServer("Stab", killer)
				end)
				task.wait(1)
				cooldown = false
			end
		end
	end
end)

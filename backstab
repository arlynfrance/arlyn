-- Full merged script
-- Features:
--   • Styled GUI (CoreGui fallback to PlayerGui)
--   • Show/hide with RightShift
--   • Smooth Backstab (TweenService)
--   • ESP toggle that fetches & runs Exunys ESP from raw.githubusercontent
--   • Automatic Drawing registration & cleanup (for Synapse Drawing)
--   • Safe fallbacks & helpful warnings

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local lp = Players.LocalPlayer

-- ======= Config / Vars =======
local backstabEnabled = false
local espEnabled = false
local cooldown = false
local lastTarget = nil
local range = 4                  -- 1..10
local mode = "Behind"            -- "Behind" or "Around"
local daggerRemote = nil
-- try to find the remote safely (adjust if your path differs)
pcall(function()
    daggerRemote = game:GetService("ReplicatedStorage"):WaitForChild("Modules", 1):WaitForChild("Network", 1):WaitForChild("RemoteEvent", 1)
end)

local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers") or workspace:FindFirstChild("Killers")

-- ======= ESP Drawing cleanup helpers (Synapse Drawing-compatible) =======
local espDrawings = {}   -- store all Drawing objects you create
local espThread = nil    -- task that will run your ESP loop
local originalDrawingNew = nil
local drawingAvailable = (type(Drawing) == "table" and type(Drawing.new) == "function")

local function registerDrawing(obj)
    if not obj then return end
    table.insert(espDrawings, obj)
    return obj
end

local function cleanupDrawings()
    for i = 1, #espDrawings do
        local obj = espDrawings[i]
        if obj then
            pcall(function()
                if type(obj.Remove) == "function" then
                    obj:Remove()
                elseif obj.Visible ~= nil then
                    obj.Visible = false
                end
            end)
        end
    end
    table.clear(espDrawings)
end

local function wrapDrawingNew()
    if not drawingAvailable then return end
    if originalDrawingNew then return end
    originalDrawingNew = Drawing.new
    Drawing.new = function(...)
        local ok, created = pcall(originalDrawingNew, ...)
        if not ok then
            return created -- propagate error object or nil
        end
        -- register if valid
        pcall(function() registerDrawing(created) end)
        return created
    end
end

local function unwrapDrawingNew()
    if not originalDrawingNew then return end
    pcall(function() Drawing.new = originalDrawingNew end)
    originalDrawingNew = nil
end

-- ======= GUI Colors & Setup =======
local COLOR_BG = Color3.fromRGB(20, 20, 20)
local COLOR_BORDER = Color3.fromRGB(80, 80, 80)
local COLOR_BTN_OFF = Color3.fromRGB(40, 40, 40)
local COLOR_BTN_ON = Color3.fromRGB(128, 0, 128) -- purple ON
local COLOR_TEXT = Color3.fromRGB(255, 255, 255)

-- Create ScreenGui and parent to CoreGui if possible (executor), fallback to PlayerGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BackstabHubV3"
screenGui.ResetOnSpawn = false

local function safeParentGui(gui)
    -- Prefer CoreGui if available (executors). Use pcall to avoid permission errors.
    local parentDone = false
    pcall(function()
        if game:GetService("CoreGui") then
            gui.Parent = game:GetService("CoreGui")
            parentDone = true
        end
    end)
    if not parentDone then
        gui.Parent = lp:WaitForChild("PlayerGui")
    end
end
safeParentGui(screenGui)

-- Main frame
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 420, 0, 178)
mainFrame.Position = UDim2.new(0, 12, 0, 12)
mainFrame.BackgroundColor3 = COLOR_BG
mainFrame.BorderColor3 = COLOR_BORDER
mainFrame.BorderSizePixel = 1
mainFrame.Parent = screenGui

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 28)
title.Position = UDim2.new(0, 0, 0, 0)
title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
title.BorderSizePixel = 0
title.Text = "MOCKS' BACKSTAB HUB V3"
title.TextColor3 = COLOR_TEXT
title.Font = Enum.Font.Code
title.TextSize = 15
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = mainFrame

-- left & right frames
local leftFrame = Instance.new("Frame")
leftFrame.Size = UDim2.new(0.5, 0, 1, -28)
leftFrame.Position = UDim2.new(0, 0, 0, 28)
leftFrame.BackgroundTransparency = 1
leftFrame.Parent = mainFrame

local rightFrame = Instance.new("Frame")
rightFrame.Size = UDim2.new(0.5, 0, 1, -28)
rightFrame.Position = UDim2.new(0.5, 0, 0, 28)
rightFrame.BackgroundTransparency = 1
rightFrame.Parent = mainFrame

local divider = Instance.new("Frame")
divider.Size = UDim2.new(0, 2, 1, -28)
divider.Position = UDim2.new(0.5, -1, 0, 28)
divider.BackgroundColor3 = COLOR_BORDER
divider.BorderSizePixel = 0
divider.Parent = mainFrame

-- ======= Left: Backstab UI =======
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 200, 0, 34)
toggleButton.Position = UDim2.new(0, 10, 0, 8)
toggleButton.BackgroundColor3 = COLOR_BTN_OFF
toggleButton.TextColor3 = COLOR_TEXT
toggleButton.Font = Enum.Font.Code
toggleButton.TextSize = 16
toggleButton.Text = "Backstab: OFF"
toggleButton.Parent = leftFrame

toggleButton.MouseButton1Click:Connect(function()
    backstabEnabled = not backstabEnabled
    if backstabEnabled then
        toggleButton.BackgroundColor3 = COLOR_BTN_ON
        toggleButton.Text = "Backstab: ON"
    else
        toggleButton.BackgroundColor3 = COLOR_BTN_OFF
        toggleButton.Text = "Backstab: OFF"
    end
end)

local rangeLabel = Instance.new("TextLabel")
rangeLabel.Size = UDim2.new(0, 200, 0, 18)
rangeLabel.Position = UDim2.new(0, 10, 0, 50)
rangeLabel.BackgroundTransparency = 1
rangeLabel.TextColor3 = COLOR_TEXT
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.Text = "Range: " .. tostring(range)
rangeLabel.Parent = leftFrame

local rangeSlider = Instance.new("TextButton")
rangeSlider.Size = UDim2.new(0, 200, 0, 18)
rangeSlider.Position = UDim2.new(0, 10, 0, 70)
rangeSlider.BackgroundColor3 = Color3.fromRGB(60,60,60)
rangeSlider.Text = ""
rangeSlider.Parent = leftFrame

local sliderFill = Instance.new("Frame")
sliderFill.Size = UDim2.new(range/10, 0, 1, 0)
sliderFill.BackgroundColor3 = COLOR_BTN_ON
sliderFill.BorderSizePixel = 0
sliderFill.Parent = rangeSlider

rangeSlider.MouseButton1Click:Connect(function()
    range = range + 1
    if range > 10 then range = 1 end
    sliderFill.Size = UDim2.new(range/10, 0, 1, 0)
    rangeLabel.Text = "Range: " .. tostring(range)
end)

local modeButton = Instance.new("TextButton")
modeButton.Size = UDim2.new(0, 200, 0, 26)
modeButton.Position = UDim2.new(0, 10, 0, 96)
modeButton.BackgroundColor3 = COLOR_BTN_OFF
modeButton.TextColor3 = COLOR_TEXT
modeButton.Font = Enum.Font.Code
modeButton.TextSize = 14
modeButton.Text = "Mode: " .. mode
modeButton.Parent = leftFrame

modeButton.MouseButton1Click:Connect(function()
    mode = (mode == "Behind") and "Around" or "Behind"
    modeButton.Text = "Mode: " .. mode
end)

-- ======= Right: ESP UI =======
local espButton = Instance.new("TextButton")
espButton.Size = UDim2.new(0, 200, 0, 34)
espButton.Position = UDim2.new(0, 10, 0, 8)
espButton.BackgroundColor3 = COLOR_BTN_OFF
espButton.TextColor3 = COLOR_TEXT
espButton.Font = Enum.Font.Code
espButton.TextSize = 16
espButton.Text = "ESP: OFF"
espButton.Parent = rightFrame

local espLabel = Instance.new("TextLabel")
espLabel.Size = UDim2.new(0, 200, 0, 18)
espLabel.Position = UDim2.new(0, 10, 0, 50)
espLabel.BackgroundTransparency = 1
espLabel.TextColor3 = COLOR_TEXT
espLabel.Font = Enum.Font.Code
espLabel.TextSize = 13
espLabel.Text = "ESP: will fetch & run Exunys ESP"
espLabel.Parent = rightFrame

-- ======= Show/Hide GUI with RightShift =======
local guiVisible = true
local function setGuiVisible(vis)
    guiVisible = vis
    mainFrame.Visible = vis
end
setGuiVisible(true)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        setGuiVisible(not guiVisible)
    end
end)

-- ======= ESP Loader & Toggle Logic =======
-- raw file URL (the one you provided)
local ESP_RAW_URL = "https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"

local function safeHttpGet(url)
    local ok, res = pcall(function()
        return (game.HttpGet and game:HttpGet(url)) or (syn and syn.request and syn.request({ Url = url, Method = "GET" }).Body) or (http and http.request and http.request({ Url = url }).Body)
    end)
    return ok and res or nil
end

espButton.MouseButton1Click:Connect(function()
    espEnabled = not espEnabled
    if espEnabled then
        espButton.BackgroundColor3 = COLOR_BTN_ON
        espButton.Text = "ESP: ON"

        -- if Drawing not available, warn and don't attempt to run remote ESP
        if not drawingAvailable then
            warn("[BackstabHub] Drawing API not available. ESP will not run.")
            return
        end

        -- wrap Drawing.new so created drawings are auto-registered
        wrapDrawingNew()

        -- Fetch the ESP file & run it in a safe task
        if not espThread or (espThread and coroutine.status(espThread) == "dead") then
            espThread = task.spawn(function()
                local raw = safeHttpGet(ESP_RAW_URL)
                if not raw then
                    warn("[BackstabHub] Could not fetch ESP from URL: " .. tostring(ESP_RAW_URL))
                    espEnabled = false
                    espButton.BackgroundColor3 = COLOR_BTN_OFF
                    espButton.Text = "ESP: OFF"
                    unwrapDrawingNew()
                    return
                end

                -- run the ESP code. Many ESP modules expect to run as a script — we just execute it.
                local ok, err = pcall(function()
                    local fn = loadstring(raw)
                    assert(fn, "loadstring failed")
                    fn()
                end)
                if not ok then
                    warn("[BackstabHub] Error running ESP module: ", err)
                    -- cleanup and disable
                    espEnabled = false
                    espButton.BackgroundColor3 = COLOR_BTN_OFF
                    espButton.Text = "ESP: OFF"
                    cleanupDrawings()
                    unwrapDrawingNew()
                    return
                end

                -- NOTE: The remote module may spawn its own loops/tasks.
                -- Because we've wrapped Drawing.new, any Drawing.new(...) calls should be auto-registered.
                -- The module may also add other connections / Instances — you should ensure it registers or cleans them on its own,
                -- or later add custom cleanup code here (for Instances not registered as drawings).

                -- Keep this task alive while espEnabled remains true so we can respond to toggles/cleanup.
                while espEnabled do
                    task.wait(0.2)
                end
            end)
        end

    else
        -- turning off
        espButton.BackgroundColor3 = COLOR_BTN_OFF
        espButton.Text = "ESP: OFF"

        -- signal loops to stop
        espEnabled = false

        -- cleanup drawings
        cleanupDrawings()

        -- restore Drawing.new to original (if it was wrapped)
        unwrapDrawingNew()

        -- additional cleanup: if the ESP module created Instances or connections (non-Drawing), 
        -- you should either have it register them to espDrawings or add cleanup here.
    end
end)

-- ======= Smooth Backstab Implementation =======
local function smoothMoveTo(part, targetCFrame, duration)
    local info = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local t = TweenService:Create(part, info, { CFrame = targetCFrame })
    t:Play()
    return t
end

local function isValidKiller(k)
    if not k then return false end
    if not k:FindFirstChild("HumanoidRootPart") then return false end
    if not k:FindFirstChild("Humanoid") then return false end
    if k.Humanoid.Health <= 0 then return false end
    return true
end

-- Main loop for smooth backstab
RunService.RenderStepped:Connect(function()
    if not backstabEnabled or cooldown then return end
    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid")) then return end
    local hrp = char.HumanoidRootPart

    if not killersFolder then return end

    for _, name in ipairs(killerNames) do
        local killer = killersFolder:FindFirstChild(name)
        if isValidKiller(killer) then
            local kHRP = killer.HumanoidRootPart
            local dist = (hrp.Position - kHRP.Position).Magnitude
            if dist <= range then
                local behindPos
                if mode == "Around" then
                    behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 1.5)
                else
                    behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                end

                cooldown = true
                lastTarget = killer

                local targetCFrame = CFrame.new(behindPos, kHRP.Position)
                local tween = smoothMoveTo(hrp, targetCFrame, 0.28)
                tween.Completed:Wait()

                -- Fire stab / dagger remote calls safely (try a few common signatures)
                pcall(function()
                    if daggerRemote then
                        pcall(function() daggerRemote:FireServer("UseActorAbility", "Dagger") end)
                        pcall(function() daggerRemote:FireServer("Stab", killer) end)
                    end
                end)

                task.wait(0.26)

                -- Reset cooldown after leaving range
                task.spawn(function()
                    task.wait(0.35)
                    while killer and killer.Parent and (hrp.Position - kHRP.Position).Magnitude <= range do
                        task.wait(0.12)
                    end
                    lastTarget = nil
                    cooldown = false
                end)

                break
            end
        end
    end
end)

-- ======= Helpful runtime messages =======
if not drawingAvailable then
    warn("[BackstabHub] Drawing library not detected. ESP will not run unless executed by an exploit that provides Drawing.")
end

-- End of script

-- Full LocalScript: Kiriot-like ESP (R6) + Fixed GUI + Tween-then-stab backstab
-- Paste into StarterPlayerScripts

-- Services & locals
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local camera = workspace.CurrentCamera

local lp = Players.LocalPlayer

-- ----------------- CONFIG / STATE -----------------
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 4.0
local mode = "behind" -- kept for UI; backstab will always tween behind when firing

-- Remote (wrapped)
local daggerRemote
pcall(function()
    daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

-- Killer names list (used to color killers red)
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killerSet = {}
for _, n in ipairs(killerNames) do killerSet[n] = true end

-- ESP state: "off"/"skeleton" (we'll implement skeleton), tracers, names
getgenv().ESP_SETTINGS = getgenv().ESP_SETTINGS or {
    espMode = "off",        -- "off" or "skeleton"
    tracers = false,
    names = false
}
local ESP = getgenv().ESP_SETTINGS

-- ----------------- VISUAL CONSTANTS -----------------
local BG_COLOR = Color3.fromRGB(37,40,45)
local PANEL_COLOR = Color3.fromRGB(42,45,50)
local ACCENT_COLOR = Color3.fromRGB(56,63,76)
local BTN_OFF = Color3.fromRGB(95,95,100)
local BTN_ON  = Color3.fromRGB(120,120,140)
local SLIDER_COLOR = Color3.fromRGB(110,110,120)
local TITLE_COLOR = Color3.fromRGB(200,200,200)
local SURV_COLOR = Color3.fromRGB(230,230,230)
local KILLER_COLOR = Color3.fromRGB(255,80,80)

local MAIN_W, MAIN_H = 540, 300
local MAIN_X, MAIN_Y = 10, 10
local OFF_Y = -350

-- ----------------- GUI BUILD -----------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MocksBackstabGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
mainFrame.Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
mainFrame.Visible = false

local outline = Instance.new("UIStroke", mainFrame)
outline.Color = ACCENT_COLOR
outline.Thickness = 3

-- Title bar
local titleBar = Instance.new("Frame", mainFrame)
titleBar.Size = UDim2.new(1, 0, 0, 28)
titleBar.Position = UDim2.new(0, 0, 0, 0)
titleBar.BackgroundColor3 = Color3.fromRGB(60,60,67)
titleBar.BorderSizePixel = 0

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1, -12, 1, 0)
titleText.Position = UDim2.new(0, 6, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "MOCKS'  BACKSTAB  SCRIPT"
titleText.Font = Enum.Font.Code
titleText.TextSize = 14
titleText.TextColor3 = TITLE_COLOR
titleText.TextXAlignment = Enum.TextXAlignment.Left

-- thin divider under title
local topDivider = Instance.new("Frame", mainFrame)
topDivider.Size = UDim2.new(1, -12, 0, 6)
topDivider.Position = UDim2.new(0, 6, 0, 28)
topDivider.BackgroundColor3 = ACCENT_COLOR
topDivider.BorderSizePixel = 0

-- left panel
local leftPanel = Instance.new("Frame", mainFrame)
leftPanel.Size = UDim2.new(0, 170, 1, -40)
leftPanel.Position = UDim2.new(0, 6, 0, 36)
leftPanel.BackgroundColor3 = PANEL_COLOR
leftPanel.BorderSizePixel = 0

-- vertical accent line touches outline
local midSep = Instance.new("Frame", mainFrame)
midSep.Size = UDim2.new(0, 6, 1, -40)
midSep.Position = UDim2.new(0, 180, 0, 36)
midSep.BackgroundColor3 = ACCENT_COLOR
midSep.BorderSizePixel = 0

-- right small panel
local rightPanel = Instance.new("Frame", mainFrame)
rightPanel.Size = UDim2.new(0, 170, 1, -40)
rightPanel.Position = UDim2.new(0, 192, 0, 36)
rightPanel.BackgroundColor3 = PANEL_COLOR
rightPanel.BorderSizePixel = 0

-- big area (visual, kept single color)
local bigArea = Instance.new("Frame", mainFrame)
bigArea.Size = UDim2.new(1, -12 - 178, 1, -46)
bigArea.Position = UDim2.new(0, 374, 0, 36)
bigArea.BackgroundColor3 = PANEL_COLOR
bigArea.BorderSizePixel = 0

-- small uniform button helper
local function makeBtn(parent, posY, text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(0, 120, 0, 28)
    b.Position = UDim2.new(0, 8, 0, posY)
    b.BackgroundColor3 = BTN_OFF
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Code
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(20,20,20)
    b.Text = text
    b.AutoButtonColor = false
    b.Parent = parent
    return b
end

-- left controls
local backstabBtn = makeBtn(leftPanel, 8, "backstab: off")
local rangeLabel = Instance.new("TextLabel", leftPanel)
rangeLabel.Size = UDim2.new(0, 150, 0, 18)
rangeLabel.Position = UDim2.new(0, 8, 0, 42)
rangeLabel.BackgroundTransparency = 1
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.TextColor3 = TITLE_COLOR
rangeLabel.Text = ("range: %.1f"):format(range)
rangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local sliderBg = Instance.new("Frame", leftPanel)
sliderBg.Size = UDim2.new(0, 150, 0, 12)
sliderBg.Position = UDim2.new(0, 8, 0, 64)
sliderBg.BackgroundColor3 = Color3.fromRGB(60,60,65)
sliderBg.BorderSizePixel = 0

local sliderFill = Instance.new("Frame", sliderBg)
sliderFill.Size = UDim2.new((range - 1) / 9, 0, 1, 0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = SLIDER_COLOR
sliderFill.BorderSizePixel = 0

local sliderKnob = Instance.new("TextButton", sliderBg)
sliderKnob.Size = UDim2.new(0, 12, 0, 12)
sliderKnob.Position = UDim2.new((range - 1) / 9, -6, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(30,30,30)
sliderKnob.BorderSizePixel = 0
sliderKnob.AutoButtonColor = false
sliderKnob.Text = ""

local modeBtn = makeBtn(leftPanel, 92, "mode:behind")

-- right controls: skeleton, tracers, names
local espBtn = makeBtn(rightPanel, 8, ("esp: %s"):format(ESP.espMode))
local tracerBtn = makeBtn(rightPanel, 44, ("tracers:%s"):format(ESP.tracers and "on" or "off"))
local namesBtn = makeBtn(rightPanel, 80, ("names:%s"):format(ESP.names and "on" or "off"))

-- top inner border
local innerTop = Instance.new("Frame", mainFrame)
innerTop.Size = UDim2.new(1, -12, 0, 6)
innerTop.Position = UDim2.new(0, 6, 0, 32)
innerTop.BackgroundColor3 = ACCENT_COLOR
innerTop.BorderSizePixel = 0

-- ----------------- GUI BEHAVIOR -----------------
local guiVisible = false
local function slideIn()
    mainFrame.Visible = true
    TweenService:Create(mainFrame, TweenInfo.new(0.38, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, MAIN_X, 0, MAIN_Y)
    }):Play()
end
local function slideOut()
    local t = TweenService:Create(mainFrame, TweenInfo.new(0.30, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
    })
    t:Play()
    t.Completed:Connect(function()
        if not guiVisible then mainFrame.Visible = false end
    end)
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        guiVisible = not guiVisible
        if guiVisible then slideIn() else slideOut() end
    end
end)

-- slider handling
local dragging = false
local function setSliderFromX(x)
    local absPos = sliderBg.AbsolutePosition.X
    local absSize = sliderBg.AbsoluteSize.X
    local localX = math.clamp(x - absPos, 0, absSize)
    local pct = (absSize > 0) and (localX / absSize) or 0
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderKnob.Position = UDim2.new(pct, -6, 0, 0)
    range = 1 + pct * 9
    rangeLabel.Text = ("range: %.1f"):format(range)
    -- persist range in session
    getgenv().ESP_SETTINGS.range = range
end

sliderKnob.MouseButton1Down:Connect(function() dragging = true end)
UserInputService.InputChanged:Connect(function(inp)
    if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then setSliderFromX(inp.Position.X) end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

-- button visuals helper
local function updateBtnVisual(btn, on)
    btn.BackgroundColor3 = on and BTN_ON or BTN_OFF
end

backstabBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
    updateBtnVisual(backstabBtn, enabled)
end)

modeBtn.MouseButton1Click:Connect(function()
    if mode == "behind" then mode = "around" else mode = "behind" end
    modeBtn.Text = "mode:" .. mode
    getgenv().ESP_SETTINGS.mode = mode
end)

local function cycleESP()
    if ESP.espMode == "off" then ESP.espMode = "skeleton"
    elseif ESP.espMode == "skeleton" then ESP.espMode = "off"
    else ESP.espMode = "off" end
    espBtn.Text = ("esp: %s"):format(ESP.espMode)
    updateBtnVisual(espBtn, ESP.espMode ~= "off")
    -- clear overlays if turning off
end
espBtn.MouseButton1Click:Connect(function() cycleESP(); getgenv().ESP_SETTINGS.espMode = ESP.espMode end)

tracerBtn.MouseButton1Click:Connect(function()
    ESP.tracers = not ESP.tracers
    tracerBtn.Text = ("tracers:%s"):format(ESP.tracers and "on" or "off")
    updateBtnVisual(tracerBtn, ESP.tracers)
    getgenv().ESP_SETTINGS.tracers = ESP.tracers
end)

namesBtn.MouseButton1Click:Connect(function()
    ESP.names = not ESP.names
    namesBtn.Text = ("names:%s"):format(ESP.names and "on" or "off")
    updateBtnVisual(namesBtn, ESP.names)
    getgenv().ESP_SETTINGS.names = ESP.names
end)

-- init visuals
updateBtnVisual(espBtn, ESP.espMode ~= "off")
updateBtnVisual(tracerBtn, ESP.tracers)
updateBtnVisual(namesBtn, ESP.names)
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)
modeBtn.Text = "mode:" .. mode

-- ----------------- OVERLAY SYSTEM (skeleton + tracers + names) -----------------
local overlayFolder = Instance.new("Folder", screenGui)
overlayFolder.Name = "Overlays"

local espOverlays = {}    -- name -> { lines = {}, nameLabel = TextLabel }
local tracerOverlays = {} -- name -> ImageLabel

-- create skeleton lines for R6 (9 lines)
local function createSkeletonLinesFor(name, color)
    local parts = {}
    for i = 1, 9 do
        local line = Instance.new("ImageLabel")
        line.Name = ("SLine_%s_%d"):format(name, i)
        line.BorderSizePixel = 0
        line.BackgroundColor3 = color
        line.BackgroundTransparency = 0
        line.Size = UDim2.new(0, 0, 0, 2)
        line.AnchorPoint = Vector2.new(0, 0.5)
        line.Position = UDim2.new(0, 0, 0, 0)
        line.Parent = overlayFolder
        parts[#parts+1] = line
    end
    return parts
end

local function createTracerFor(name)
    local t = Instance.new("ImageLabel")
    t.Name = "Tracer_" .. name
    t.BorderSizePixel = 0
    t.BackgroundColor3 = Color3.fromRGB(255,255,255)
    t.Size = UDim2.new(0, 0, 0, 2)
    t.AnchorPoint = Vector2.new(0, 0.5)
    t.Position = UDim2.new(0, 0, 0, 0)
    t.Parent = overlayFolder
    return t
end

local function createNameLabelFor(name, color)
    local lbl = Instance.new("TextLabel")
    lbl.Name = "Name_" .. name
    lbl.Size = UDim2.new(0,200,0,20)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Code
    lbl.TextSize = 16
    lbl.TextColor3 = color
    lbl.Text = name
    lbl.Parent = overlayFolder
    return lbl
end

local function removeOverlaysFor(name)
    if espOverlays[name] then
        if espOverlays[name].lines then
            for _,l in ipairs(espOverlays[name].lines) do if l and l.Parent then l:Destroy() end end
        end
        if espOverlays[name].nameLabel and espOverlays[name].nameLabel.Parent then espOverlays[name].nameLabel:Destroy() end
        espOverlays[name] = nil
    end
    if tracerOverlays[name] and tracerOverlays[name].Parent then tracerOverlays[name]:Destroy() end
    tracerOverlays[name] = nil
end

Players.PlayerRemoving:Connect(function(plr) removeOverlaysFor(plr.Name) end)

-- R6 joint fetcher (positions)
local function getR6Joints(char)
    if not char then return nil end
    local joints = {}
    local head = char:FindFirstChild("Head")
    local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
    local larm = char:FindFirstChild("Left Arm")
    local rarm = char:FindFirstChild("Right Arm")
    local lleg = char:FindFirstChild("Left Leg")
    local rleg = char:FindFirstChild("Right Leg")
    local lhand = char:FindFirstChild("LeftHand") or char:FindFirstChild("Left Hand")
    local rhand = char:FindFirstChild("RightHand") or char:FindFirstChild("Right Hand")
    local lfoot = char:FindFirstChild("LeftFoot") or char:FindFirstChild("Left Foot")
    local rfoot = char:FindFirstChild("RightFoot") or char:FindFirstChild("Right Foot")
    local hrp = char:FindFirstChild("HumanoidRootPart")

    local function pos(p, fallback)
        if p and p:IsA("BasePart") then return p.Position end
        if hrp then return hrp.Position + (fallback or Vector3.new(0,0,0)) end
        return nil
    end

    joints.Head = pos(head, Vector3.new(0,2,0))
    joints.Torso = pos(torso, Vector3.new(0,1,0))
    joints.LeftArm = pos(larm, Vector3.new(-0.5,1,0))
    joints.RightArm = pos(rarm, Vector3.new(0.5,1,0))
    joints.LeftLeg = pos(lleg, Vector3.new(-0.3,-1,0))
    joints.RightLeg = pos(rleg, Vector3.new(0.3,-1,0))
    joints.LeftHand = pos(lhand) or (joints.LeftArm and joints.LeftArm + Vector3.new(0,-0.6,0))
    joints.RightHand = pos(rhand) or (joints.RightArm and joints.RightArm + Vector3.new(0,-0.6,0))
    joints.LeftFoot = pos(lfoot) or (joints.LeftLeg and joints.LeftLeg + Vector3.new(0,-0.8,0))
    joints.RightFoot = pos(rfoot) or (joints.RightLeg and joints.RightLeg + Vector3.new(0,-0.8,0))

    if not joints.Torso and hrp then joints.Torso = hrp.Position end
    return joints
end

local function worldToScreen(vec3)
    local p, on = camera:WorldToViewportPoint(vec3)
    return Vector2.new(p.X, p.Y), on
end

-- ----------------- TWEEN-THEN-STAB FUNCTION -----------------
-- Tweens behind the target for 'duration' seconds, then fires dagger
local function tweenBehindAndStab(targetHRP, duration)
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = lp.Character.HumanoidRootPart
    if not (targetHRP and targetHRP.Parent) then return end

    -- position behind target (small offset behind)
    local behindOffset = 0.6 -- studs behind; small so we're close
    local behindPos = targetHRP.Position - (targetHRP.CFrame.LookVector * behindOffset)
    local targetCFrame = CFrame.new(behindPos, behindPos + targetHRP.CFrame.LookVector)

    -- create tween
    local ok, tween = pcall(function()
        return TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { CFrame = targetCFrame })
    end)
    if not ok or not tween then
        -- fallback to instant set then dagger
        pcall(function()
            hrp.CFrame = targetCFrame
            if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end
        end)
        return
    end

    -- play tween; when finished, align and stab
    local finished = false
    tween:Play()
    local conn
    conn = tween.Completed:Connect(function(state)
        if conn then conn:Disconnect() end
        -- ensure target still present
        if not (targetHRP and targetHRP.Parent) then return end
        -- align facing
        if hrp and hrp.Parent then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + targetHRP.CFrame.LookVector) end
        -- fire dagger safely
        pcall(function() if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end end)
    end)

    -- safety: if target disappears mid-tween or local char removed, cancel callback
    task.delay(duration + 0.1, function()
        if conn and conn.Connected then conn:Disconnect() end
    end)
end

-- ----------------- MAIN LOOP -----------------
RunService.RenderStepped:Connect(function()
    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then
        -- remove overlays if no local char
        for name,_ in pairs(espOverlays) do removeOverlaysFor(name) end
        for name,_ in pairs(tracerOverlays) do removeOverlaysFor(name) end
        return
    end
    local hrp = char.HumanoidRootPart

    -- Update ESP overlays per other player
    for _, other in ipairs(Players:GetPlayers()) do
        if other ~= lp then
            local otherChar = other.Character
            local root = otherChar and (otherChar:FindFirstChild("HumanoidRootPart") or otherChar:FindFirstChild("Torso") or otherChar:FindFirstChild("UpperTorso"))
            if root then
                local name = other.Name
                local isKiller = killerSet[name]
                local color = isKiller and KILLER_COLOR or SURV_COLOR

                -- ensure overlay structures exist if enabled
                if ESP.espMode ~= "off" and not espOverlays[name] then
                    espOverlays[name] = { lines = nil, nameLabel = nil }
                    if ESP.espMode == "skeleton" then espOverlays[name].lines = createSkeletonLinesFor(name, color) end
                    if ESP.names then espOverlays[name].nameLabel = createNameLabelFor(name, color) end
                end

                -- recreate if mode changed
                if espOverlays[name] then
                    if ESP.espMode == "skeleton" and not espOverlays[name].lines then
                        if espOverlays[name].nameLabel and espOverlays[name].nameLabel.Parent then espOverlays[name].nameLabel.Parent = overlayFolder end
                        espOverlays[name].lines = createSkeletonLinesFor(name, color)
                    elseif ESP.espMode == "off" then
                        removeOverlaysFor(name)
                    end
                end

                -- skeleton rendering
                if ESP.espMode == "skeleton" and espOverlays[name] and espOverlays[name].lines then
                    local joints = getR6Joints(otherChar)
                    if joints then
                        local connections = {
                            {joints.Head, joints.Torso},
                            {joints.Torso, joints.LeftArm},
                            {joints.LeftArm, joints.LeftHand},
                            {joints.Torso, joints.RightArm},
                            {joints.RightArm, joints.RightHand},
                            {joints.Torso, joints.LeftLeg},
                            {joints.LeftLeg, joints.LeftFoot},
                            {joints.Torso, joints.RightLeg},
                            {joints.RightLeg, joints.RightFoot},
                        }
                        local anyVis = false
                        for i, pair in ipairs(connections) do
                            local a, b = pair[1], pair[2]
                            local line = espOverlays[name].lines[i]
                            if a and b and line then
                                local a2, aOn = worldToScreen(a)
                                local b2, bOn = worldToScreen(b)
                                if aOn or bOn then
                                    anyVis = true
                                    local delta = b2 - a2
                                    local dist = math.max(2, delta.Magnitude)
                                    local angle = math.deg(math.atan2(delta.Y, delta.X))
                                    line.Size = UDim2.new(0, math.floor(dist), 0, 2)
                                    line.Position = UDim2.new(0, a2.X, 0, a2.Y)
                                    line.Rotation = angle
                                    line.AnchorPoint = Vector2.new(0, 0.5)
                                    line.Visible = true
                                    line.BackgroundColor3 = color
                                else
                                    line.Visible = false
                                end
                            end
                        end
                        if not anyVis then
                            for _, l in ipairs(espOverlays[name].lines) do l.Visible = false end
                        end
                    end
                end

                -- names
                if ESP.names and espOverlays[name] then
                    if not espOverlays[name].nameLabel then espOverlays[name].nameLabel = createNameLabelFor(name, color) end
                    local head = otherChar:FindFirstChild("Head")
                    local posWorld = head and (head.Position + Vector3.new(0,0.5,0)) or (root.Position + Vector3.new(0,1.5,0))
                    local pos2, on = worldToScreen(posWorld)
                    local lbl = espOverlays[name].nameLabel
                    if on then
                        lbl.Position = UDim2.new(0, pos2.X - (lbl.AbsoluteSize.X/2), 0, pos2.Y - 24)
                        lbl.Visible = true
                        lbl.TextColor3 = color
                    else
                        lbl.Visible = false
                    end
                elseif espOverlays[name] and espOverlays[name].nameLabel then
                    if espOverlays[name].nameLabel.Parent then espOverlays[name].nameLabel:Destroy() end
                    espOverlays[name].nameLabel = nil
                end

                -- tracers
                if ESP.tracers then
                    if not tracerOverlays[name] then tracerOverlays[name] = createTracerFor(name) end
                    local tracer = tracerOverlays[name]
                    local headWorld = (otherChar and otherChar:FindFirstChild("Head") and otherChar.Head.Position) or (root.Position + Vector3.new(0,1.5,0))
                    local head2, headOn = worldToScreen(headWorld)
                    local origin = Vector2.new(camera.ViewportSize.X * 0.5, camera.ViewportSize.Y - 36)
                    local delta = head2 - origin
                    local dist = math.max(2, delta.Magnitude)
                    local angle = math.deg(math.atan2(delta.Y, delta.X))
                    tracer.Size = UDim2.new(0, math.floor(dist), 0, 2)
                    tracer.Position = UDim2.new(0, origin.X, 0, origin.Y)
                    tracer.Rotation = angle
                    tracer.AnchorPoint = Vector2.new(0, 0.5)
                    tracer.BackgroundColor3 = color
                    tracer.Visible = headOn
                else
                    if tracerOverlays[name] then tracerOverlays[name].Visible = false end
                end
            else
                -- cleanup if no character
                if espOverlays[other.Name] or tracerOverlays[other.Name] then removeOverlaysFor(other.Name) end
            end
        end
    end

    -- ------------- BACKSTAB detection and tween-to-stab -------------
    -- Build list of candidate targets: prefer workspace.Players.Killers if present, else other players' characters
    local killersToCheck = {}
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, nm in ipairs(killerNames) do
            local k = killersFolder:FindFirstChild(nm)
            if k and k:FindFirstChild("HumanoidRootPart") then table.insert(killersToCheck, k) end
        end
    end
    if #killersToCheck == 0 then
        for _, other in ipairs(Players:GetPlayers()) do
            if other ~= lp and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(killersToCheck, other.Character)
            end
        end
    end

    for _, kobj in ipairs(killersToCheck) do
        local kHRP = kobj and kobj:FindFirstChild("HumanoidRootPart")
        if kHRP then
            if enabled and not cooldown and isBehindTarget(hrp, kHRP) and kobj ~= lastTarget then
                cooldown = true
                lastTarget = kobj

                -- Tween behind target for 0.20s and then stab
                tweenBehindAndStab(kHRP, 0.20)

                -- Reset cooldown after leaving range (preserve original behavior)
                task.delay(2, function()
                    RunService.Heartbeat:Wait()
                    while isBehindTarget(hrp, kHRP) do RunService.Heartbeat:Wait() end
                    lastTarget = nil
                    cooldown = false
                end)

                break
            end
        end
    end
end)

-- Persist visual button text & save to getgenv
espBtn.Text = ("esp: %s"):format(ESP.espMode)
tracerBtn.Text = ("tracers:%s"):format(ESP.tracers and "on" or "off")
namesBtn.Text = ("names:%s"):format(ESP.names and "on" or "off")
updateBtnVisual(espBtn, ESP.espMode ~= "off")
updateBtnVisual(tracerBtn, ESP.tracers)
updateBtnVisual(namesBtn, ESP.names)

getgenv().ESP_SETTINGS = ESP

-- ------------- isBehindTarget (keeps your original logic) -------------
function isBehindTarget(hrp, targetHRP)
    local dist = (hrp.Position - targetHRP.Position).Magnitude
    if dist > range then return false end
    if mode == "around" then return true end
    local direction = -targetHRP.CFrame.LookVector
    local toPlayer = (hrp.Position - targetHRP.Position)
    return toPlayer:Dot(direction) > 0.5
end

-- End of script

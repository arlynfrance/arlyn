-- Full Integrated LocalScript
-- GUI (matches screenshot) + mobile arrow toggle + dual-ESP (PC Drawing via Exunys, Mobile Highlight-based)
-- + Backstab logic preserved (Quad tween), Range slider fixed, draggable GUI, RightShift toggle.
-- Place into StarterPlayerScripts as a LocalScript.

-- SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")

local lp = Players.LocalPlayer
local camera = Workspace.CurrentCamera

-- ========================
-- Config / preserved behavior
-- ========================
local enabled = false       -- backstab enabled
local cooldown = false
local lastTarget = nil
local range = 7.2           -- default range (will be restored from attribute if present)
local mode = "Behind"       -- "Behind" or "Around"
local daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

-- Restore stored range from attribute if present
if lp:GetAttribute("BackstabRange") then
	local attr = lp:GetAttribute("BackstabRange")
	if type(attr) == "number" then range = attr end
end

-- UI Colors
local BG = Color3.fromRGB(40,40,42)
local PANEL = Color3.fromRGB(60,60,70)
local ACCENT = Color3.fromRGB(160,170,200)
local TEXT = Color3.fromRGB(230,230,230)

-- Platform detection
local function isMobile()
	-- Consider touch enabled + not keyboard as mobile
	local uis = UserInputService
	return uis.TouchEnabled and not uis.KeyboardEnabled
end
local function isPC()
	local uis = UserInputService
	return uis.KeyboardEnabled or uis.MouseEnabled
end

local PLATFORM_IS_MOBILE = isMobile()
local PLATFORM_IS_PC = not PLATFORM_IS_MOBILE

-- ========================
-- GUI BUILD
-- ========================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BackstabHubV3"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")
screenGui.Enabled = true -- fixed visibility issue: start visible

local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0,520,0,320)
main.Position = UDim2.new(0,20,0,20)
main.BackgroundColor3 = BG
main.BorderColor3 = PANEL
main.BorderSizePixel = 3
main.Parent = screenGui

-- Title bar
local title = Instance.new("Frame", main)
title.Name = "Title"
title.Size = UDim2.new(1,0,0,30)
title.BackgroundColor3 = PANEL
title.BorderSizePixel = 0

local titleLabel = Instance.new("TextLabel", title)
titleLabel.Size = UDim2.new(1,-12,1,0)
titleLabel.Position = UDim2.new(0,6,0,0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "MOCKS' BACKSTAB HUB V3"
titleLabel.TextColor3 = TEXT
titleLabel.Font = Enum.Font.Code
titleLabel.TextSize = 18
titleLabel.TextXAlignment = Enum.TextXAlignment.Left

-- divider
local divider = Instance.new("Frame", main)
divider.Size = UDim2.new(1,0,0,6)
divider.Position = UDim2.new(0,0,0,30)
divider.BackgroundColor3 = PANEL
divider.BorderSizePixel = 0

-- left column & right panel
local leftCol = Instance.new("Frame", main)
leftCol.Name = "Left"
leftCol.Size = UDim2.new(0,170,1,-36)
leftCol.Position = UDim2.new(0,6,0,36)
leftCol.BackgroundTransparency = 1

local rightPanel = Instance.new("Frame", main)
rightPanel.Name = "Right"
rightPanel.Size = UDim2.new(1,-188,1,-36)
rightPanel.Position = UDim2.new(0,182,0,36)
rightPanel.BackgroundColor3 = BG
rightPanel.BorderColor3 = PANEL
rightPanel.BorderSizePixel = 0

-- left background visual
local leftBg = Instance.new("Frame", main)
leftBg.Size = UDim2.new(0,164,1,-36)
leftBg.Position = UDim2.new(0,3,0,36)
leftBg.BackgroundColor3 = BG
leftBg.BorderColor3 = PANEL
leftBg.BorderSizePixel = 0
leftBg.ZIndex = main.ZIndex - 1

-- helper for left buttons
local function makeLeftButton(y, text)
	local b = Instance.new("TextButton")
	b.Size = UDim2.new(1,-6,0,30)
	b.Position = UDim2.new(0,3,0,y)
	b.BackgroundColor3 = PANEL
	b.TextColor3 = TEXT
	b.Font = Enum.Font.Code
	b.TextSize = 16
	b.Text = text
	b.Parent = leftCol
	local stroke = Instance.new("UIStroke", b)
	stroke.Color = Color3.fromRGB(80,80,90)
	stroke.Thickness = 1
	return b
end

-- Backstab button
local backstabBtn = makeLeftButton(4, "backstab: off")

-- Range label (panel style)
local rangeLabel = Instance.new("TextLabel", leftCol)
rangeLabel.Size = UDim2.new(1,-6,0,26)
rangeLabel.Position = UDim2.new(0,3,0,40)
rangeLabel.BackgroundColor3 = PANEL
rangeLabel.TextColor3 = TEXT
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.Text = "range: " .. tostring(range)
local rsStroke = Instance.new("UIStroke", rangeLabel)
rsStroke.Color = Color3.fromRGB(80,80,90)

-- Slider frame
local sliderFrame = Instance.new("Frame", leftCol)
sliderFrame.Size = UDim2.new(1,-12,0,16)
sliderFrame.Position = UDim2.new(0,6,0,70)
sliderFrame.BackgroundColor3 = Color3.fromRGB(100,100,110)
sliderFrame.BorderSizePixel = 0
local sliderStroke = Instance.new("UIStroke", sliderFrame)
sliderStroke.Color = Color3.fromRGB(80,80,90)

local sliderFill = Instance.new("Frame", sliderFrame)
sliderFill.Size = UDim2.new((range - 1) / 9,0,1,0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = ACCENT
sliderFill.BorderSizePixel = 0

-- Knob (centered anchor fixes misalignment)
local knobSizePx = 12
local sliderKnob = Instance.new("Frame", sliderFrame)
sliderKnob.Name = "Knob"
sliderKnob.Size = UDim2.new(0, knobSizePx, 0, knobSizePx)
sliderKnob.AnchorPoint = Vector2.new(0.5, 0.5)
sliderKnob.Position = UDim2.new((range - 1) / 9, 0, 0.5, 0)
sliderKnob.BackgroundColor3 = ACCENT
local knobCorner = Instance.new("UICorner", sliderKnob)
knobCorner.CornerRadius = UDim.new(0,4)

-- Mode button
local modeBtn = makeLeftButton(98, "mode:" .. string.lower(mode))

-- ESP button (in right panel top left)
local espBtn = Instance.new("TextButton", rightPanel)
espBtn.Size = UDim2.new(0,120,0,30)
espBtn.Position = UDim2.new(0,8,0,8)
espBtn.BackgroundColor3 = PANEL
espBtn.Text = "esp: off"
espBtn.TextColor3 = TEXT
espBtn.Font = Enum.Font.Code
espBtn.TextSize = 16
local espStroke = Instance.new("UIStroke", espBtn)
espStroke.Color = Color3.fromRGB(80,80,90)

-- Mobile arrow (always visible) bottom center
local arrowBtn = Instance.new("ImageButton")
arrowBtn.Name = "MobileArrow"
arrowBtn.Size = UDim2.new(0,56,0,40)
arrowBtn.AnchorPoint = Vector2.new(0.5, 1)
arrowBtn.Position = UDim2.new(0.5, 0, 1, -4) -- bottom center, slight offset
arrowBtn.Parent = screenGui
arrowBtn.BackgroundColor3 = Color3.fromRGB(50,50,55)
arrowBtn.ZIndex = 10
arrowBtn.Image = "" -- no image by default; use triangle drawn via Frame and UICorner below

-- draw arrow triangle inside
local tri = Instance.new("Frame", arrowBtn)
tri.Size = UDim2.new(0,28,0,16)
tri.Position = UDim2.new(0.5,-14,0.5,-8)
tri.AnchorPoint = Vector2.new(0,0)
tri.BackgroundColor3 = ACCENT
tri.BorderSizePixel = 0
tri.Rotation = 0
-- small caret effect using UICorner to look like a rounded triangle-ish rectangle
local triCorner = Instance.new("UICorner", tri)
triCorner.CornerRadius = UDim.new(0,4)

-- make arrow always visible on all platforms (user asked)
arrowBtn.Visible = true

-- Left background z-order fix (so left items appear)
leftBg.ZIndex = main.ZIndex + 1

-- ========================
-- Draggable title bar
-- ========================
main.Active = true
local dragging = false
local dragStart = Vector2.new()
local mainStartPos = UDim2.new()
title.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		mainStartPos = main.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		main.Position = UDim2.new(mainStartPos.X.Scale, mainStartPos.X.Offset + delta.X, mainStartPos.Y.Scale, mainStartPos.Y.Offset + delta.Y)
	end
end)

-- RightShift toggles GUI on PC
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.RightShift then
		screenGui.Enabled = not screenGui.Enabled
	end
end)

-- Mobile arrow toggles GUI (always visible)
arrowBtn.MouseButton1Click:Connect(function()
	screenGui.Enabled = not screenGui.Enabled
end)

-- ========================
-- Slider logic (1.0 -> 10.0, 0.1 steps)
-- ========================
local sliding = false
local function setRangeFromRel(rel)
	rel = math.clamp(rel, 0, 1)
	-- convert to 1..10
	local raw = 1 + rel * 9
	range = math.floor(raw * 10 + 0.5) / 10 -- rounded to 0.1
	sliderFill.Size = UDim2.new(rel, 0, 1, 0)
	sliderKnob.Position = UDim2.new(rel, 0, 0.5, 0)
	rangeLabel.Text = "range: " .. tostring(range)
	pcall(function() lp:SetAttribute("BackstabRange", range) end)
end

sliderKnob.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then sliding = true end end)
sliderKnob.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then sliding = false end end)

sliderFrame.InputBegan:Connect(function(i)
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		local relX = math.clamp((i.Position.X - sliderFrame.AbsolutePosition.X) / sliderFrame.AbsoluteSize.X, 0, 1)
		setRangeFromRel(relX)
	end
end)

UserInputService.InputChanged:Connect(function(i)
	if sliding and i.UserInputType == Enum.UserInputType.MouseMovement then
		local relX = math.clamp((i.Position.X - sliderFrame.AbsolutePosition.X) / sliderFrame.AbsoluteSize.X, 0, 1)
		setRangeFromRel(relX)
	end
end)

-- initialize visuals
setRangeFromRel((range - 1) / 9)

-- ========================
-- Button behaviors (backstab/mode)
-- ========================
backstabBtn.MouseButton1Click:Connect(function()
	enabled = not enabled
	backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
	backstabBtn.BackgroundColor3 = (enabled and ACCENT) or PANEL
end)

modeBtn.MouseButton1Click:Connect(function()
	mode = (mode == "Behind") and "Around" or "Behind"
	modeBtn.Text = "mode:" .. string.lower(mode)
end)

-- ========================
-- Dual ESP: PC (Exunys Drawing) & Mobile (Highlight-based)
-- ========================

-- ---- PC ESP loader/manager ----
local PC_ESP = {
	loaded = false,
	loadedReturn = nil, -- whatever chunk returns
	-- try different toggles: expected patterns: returnedModule.Toggle(bool), returnedModule.Enabled = bool,
	-- or global variables like _G.ESPEnabled/_G.ESPVisible or global "ESP" table.
}

local PC_ESP_URL = "https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"

local function pc_enable()
	-- try to load if needed
	if not PC_ESP.loaded then
		local ok, raw = pcall(function() return game:HttpGet(PC_ESP_URL) end)
		if not ok or type(raw) ~= "string" or raw == "" then
			warn("BackstabHub: Could not fetch PC ESP (HttpGet failed).")
			return false
		end

		local compileOk, chunk = pcall(function()
			return loadstring and loadstring(raw) or load(raw)
		end)
		if not compileOk or type(chunk) ~= "function" then
			warn("BackstabHub: Failed to compile PC ESP chunk.")
			return false
		end

		local runOk, returned = pcall(function()
			-- run chunk; some ESPs return a module/table, others set globals
			return chunk()
		end)
		if not runOk then
			warn("BackstabHub: Error while running PC ESP chunk:", returned)
			return false
		end

		PC_ESP.loaded = true
		PC_ESP.loadedReturn = returned
	end

	-- now try to enable in many ways:
	-- 1) if returned is table and has Toggle
	if type(PC_ESP.loadedReturn) == "table" then
		local ret = PC_ESP.loadedReturn
		if type(ret.Toggle) == "function" then
			pcall(function() ret.Toggle(true) end)
			return true
		elseif type(ret.Enable) == "function" then
			pcall(function() ret.Enable() end)
			return true
		elseif ret.Enabled ~= nil then
			pcall(function() ret.Enabled = true end)
			return true
		end
	end

	-- 2) check common globals
	local g = _G
	if g.ESPVisible ~= nil then
		pcall(function() g.ESPVisible = true end)
		return true
	end
	if g.ESPEnabled ~= nil then
		pcall(function() g.ESPEnabled = true end)
		return true
	end
	if g.Exunys and type(g.Exunys.Toggle) == "function" then
		pcall(function() g.Exunys.Toggle(true) end)
		return true
	end
	-- 3) check for returned function directly
	if type(PC_ESP.loadedReturn) == "function" then
		-- some scripts return a function to start; call it
		pcall(function() PC_ESP.loadedReturn(true) end)
		-- we cannot be 100% sure but return true anyway
		return true
	end

	-- If we got here, we attempted but couldn't find a control point. We'll attempt to set common globals that ESP scripts might observe:
	pcall(function() _G.ESPVisible = true end)
	pcall(function() _G.ESPEnabled = true end)
	-- success is uncertain:
	return true
end

local function pc_disable()
	-- try to disable gracefully
	if type(PC_ESP.loadedReturn) == "table" then
		local ret = PC_ESP.loadedReturn
		if type(ret.Toggle) == "function" then
			pcall(function() ret.Toggle(false) end)
			return true
		elseif ret.Enabled ~= nil then
			pcall(function() ret.Enabled = false end)
			return true
		end
	end
	-- try globals
	pcall(function() _G.ESPVisible = false end)
	pcall(function() _G.ESPEnabled = false end)
	return true
end

-- ---- Mobile Highlight-based ESP (self-contained; mirrors PC visual features) ----
local mobileESP = {
	enabled = false,
	players = {}, -- map player -> data (highlight, billboard, box frames, tracer, conn)
	playerAddedConn = nil
}
local MOBILE_ESP_TEAM_CHECK = false -- change to true to avoid showing teammates

local function createMobileESPForPlayer(plr)
	if not plr or plr == lp then return end
	if mobileESP.players[plr] then return end
	if not plr.Character then return end
	local char = plr.Character
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hrp or not hum then return end

	-- Highlight as "chams"
	local hl = Instance.new("Highlight")
	hl.Adornee = char
	hl.FillTransparency = 0.7
	hl.OutlineTransparency = 0
	hl.OutlineColor = Color3.new(1,1,1)
	hl.Parent = Workspace

	-- Billboard for name/health/distance
	local bill = Instance.new("BillboardGui")
	bill.Adornee = hrp
	bill.Size = UDim2.new(0,160,0,56)
	bill.StudsOffset = Vector3.new(0,2.25,0)
	bill.AlwaysOnTop = true
	bill.Parent = screenGui

	local frame = Instance.new("Frame", bill)
	frame.Size = UDim2.new(1,0,1,0)
	frame.BackgroundTransparency = 1

	local nameLabel = Instance.new("TextLabel", frame)
	nameLabel.Size = UDim2.new(1,0,0,18)
	nameLabel.Position = UDim2.new(0,0,0,0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.Code
	nameLabel.TextSize = 14
	nameLabel.TextColor3 = Color3.new(1,1,1)
	nameLabel.Text = plr.Name

	local healthOuter = Instance.new("Frame", frame)
	healthOuter.Size = UDim2.new(1,-10,0,8)
	healthOuter.Position = UDim2.new(0,5,0,20)
	healthOuter.BackgroundColor3 = Color3.fromRGB(30,30,30)
	healthOuter.BorderSizePixel = 0

	local healthBar = Instance.new("Frame", healthOuter)
	healthBar.Size = UDim2.new(1,0,1,0)
	healthBar.BackgroundColor3 = Color3.fromRGB(0,200,100)
	healthBar.BorderSizePixel = 0

	local distLabel = Instance.new("TextLabel", frame)
	distLabel.Size = UDim2.new(1,0,0,14)
	distLabel.Position = UDim2.new(0,0,0,30)
	distLabel.BackgroundTransparency = 1
	distLabel.Font = Enum.Font.Code
	distLabel.TextSize = 12
	distLabel.TextColor3 = Color3.new(1,1,1)
	distLabel.Text = ""

	-- 2D box frames in screenGui
	local boxTop = Instance.new("Frame", screenGui)
	boxTop.BackgroundColor3 = ACCENT
	boxTop.Size = UDim2.new(0,0,0,2)
	boxTop.BorderSizePixel = 0

	local boxBottom = Instance.new("Frame", screenGui)
	boxBottom.BackgroundColor3 = ACCENT
	boxBottom.Size = UDim2.new(0,0,0,2)
	boxBottom.BorderSizePixel = 0

	local boxLeft = Instance.new("Frame", screenGui)
	boxLeft.BackgroundColor3 = ACCENT
	boxLeft.Size = UDim2.new(0,2,0,0)

	local boxRight = Instance.new("Frame", screenGui)
	boxRight.BackgroundColor3 = ACCENT
	boxRight.Size = UDim2.new(0,2,0,0)

	local tracer = Instance.new("Frame", screenGui)
	tracer.BackgroundColor3 = ACCENT
	tracer.BorderSizePixel = 0
	tracer.AnchorPoint = Vector2.new(0.5, 1)
	tracer.Size = UDim2.new(0,2,0,0)
	tracer.Visible = true

	local conn = RunService.RenderStepped:Connect(function()
		if not mobileESP.enabled then return end
		if not plr.Parent or not plr.Character then return end
		local ch = plr.Character
		local hr = ch:FindFirstChild("HumanoidRootPart")
		local head = ch:FindFirstChild("Head")
		local h = ch:FindFirstChildOfClass("Humanoid")
		if not hr or not head then
			boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = false
			tracer.Visible = false
			bill.Enabled = false
			hl.Enabled = false
			return
		end

		-- team check
		if MOBILE_ESP_TEAM_CHECK and plr.Team and lp.Team and plr.Team == lp.Team then
			boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = false
			tracer.Visible = false
			bill.Enabled = false
			hl.Enabled = false
			return
		end

		hl.Enabled = true
		bill.Enabled = true

		-- update health
		if h then
			local pct = math.clamp(h.Health / math.max(h.MaxHealth,1), 0, 1)
			healthBar.Size = UDim2.new(pct,0,1,0)
		end

		-- compute 2D box
		local headPos = head.Position
		local rootPos = hr.Position
		local headScreen, headOn = camera:WorldToViewportPoint(headPos)
		local rootScreen, rootOn = camera:WorldToViewportPoint(rootPos)
		if not headOn and not rootOn then
			boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = false
			tracer.Visible = false
			bill.Enabled = false
			hl.Enabled = false
			return
		end

		local hx, hy = headScreen.X, headScreen.Y
		local rx, ry = rootScreen.X, rootScreen.Y
		local boxHeight = math.max(20, math.abs(ry - hy))
		local boxWidth = math.max(12, boxHeight * 0.5)
		local centerX = (hx + rx) / 2
		local topY = math.min(hy, ry) - math.max(8, boxHeight * 0.15)
		local bottomY = math.max(hy, ry) + math.max(8, boxHeight * 0.05)
		local leftX = centerX - boxWidth/2
		local rightX = centerX + boxWidth/2
		local height = math.max(12, bottomY - topY)

		boxTop.Position = UDim2.new(0, leftX, 0, topY)
		boxTop.Size = UDim2.new(0, rightX - leftX, 0, 2)

		boxBottom.Position = UDim2.new(0, leftX, 0, bottomY - 2)
		boxBottom.Size = UDim2.new(0, rightX - leftX, 0, 2)

		boxLeft.Position = UDim2.new(0, leftX, 0, topY)
		boxLeft.Size = UDim2.new(0, 2, 0, height)

		boxRight.Position = UDim2.new(0, rightX - 2, 0, topY)
		boxRight.Size = UDim2.new(0, 2, 0, height)

		boxTop.Visible = boxBottom.Visible = boxLeft.Visible = boxRight.Visible = true

		-- update distance display
		local myHrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
		if myHrp and hr then
			local d = (hr.Position - myHrp.Position).Magnitude
			distLabel.Text = string.format("%.1fm", d)
		end

		-- tracer
		local viewport = camera.ViewportSize
		local sx, sy = viewport.X * 0.5, viewport.Y - 8
		local tx, ty = centerX, topY + height * 0.5
		local dx, dy = tx - sx, ty - sy
		local length = math.sqrt(dx*dx + dy*dy)
		if length > 2 then
			tracer.Visible = true
			local angle = math.deg(math.atan2(dy, dx)) - 90
			tracer.Size = UDim2.new(0, 2, 0, length)
			tracer.Position = UDim2.new(0, sx, 0, sy)
			tracer.AnchorPoint = Vector2.new(0.5, 1)
			tracer.Rotation = angle
		else
			tracer.Visible = false
		end
	end)

	mobileESP.players[plr] = {
		highlight = hl,
		bill = bill,
		boxTop = boxTop, boxBottom = boxBottom, boxLeft = boxLeft, boxRight = boxRight,
		tracer = tracer,
		conn = conn
	}
end

local function removeMobileESPForPlayer(plr)
	local data = mobileESP.players[plr]
	if not data then return end
	pcall(function()
		if data.conn and data.conn.Disconnect then data.conn:Disconnect() end
		if data.highlight and data.highlight.Parent then data.highlight:Destroy() end
		if data.bill and data.bill.Parent then data.bill:Destroy() end
		if data.boxTop and data.boxTop.Parent then data.boxTop:Destroy() end
		if data.boxBottom and data.boxBottom.Parent then data.boxBottom:Destroy() end
		if data.boxLeft and data.boxLeft.Parent then data.boxLeft:Destroy() end
		if data.boxRight and data.boxRight.Parent then data.boxRight:Destroy() end
		if data.tracer and data.tracer.Parent then data.tracer:Destroy() end
	end)
	mobileESP.players[plr] = nil
end

local function enableMobileESP()
	if mobileESP.enabled then return end
	mobileESP.enabled = true
	for _,p in ipairs(Players:GetPlayers()) do
		if p ~= lp and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			createMobileESPForPlayer(p)
		end
		-- ensure respawn handling
		p.CharacterAdded:Connect(function(char)
			task.wait(0.05)
			if mobileESP.enabled and p ~= lp and char:FindFirstChild("HumanoidRootPart") then
				removeMobileESPForPlayer(p)
				createMobileESPForPlayer(p)
			end
		end)
	end
	if not mobileESP.playerAddedConn then
		mobileESP.playerAddedConn = Players.PlayerAdded:Connect(function(plr)
			plr.CharacterAdded:Connect(function(char)
				task.wait(0.05)
				if mobileESP.enabled and plr ~= lp and char:FindFirstChild("HumanoidRootPart") then
					createMobileESPForPlayer(plr)
				end
			end)
		end)
	end
end

local function disableMobileESP()
	if not mobileESP.enabled then return end
	mobileESP.enabled = false
	if mobileESP.playerAddedConn then mobileESP.playerAddedConn:Disconnect() mobileESP.playerAddedConn = nil end
	for p,_ in pairs(mobileESP.players) do
		removeMobileESPForPlayer(p)
	end
	mobileESP.players = {}
end

-- Unified toggle (button handler will call this)
local currentESPMode = nil -- "PC" or "MOBILE"
local function enableESPUnified()
	if PLATFORM_IS_PC then
		currentESPMode = "PC"
		local ok = pc_enable()
		-- fallback to Mobile if PC enabling failed
		if not ok then
			currentESPMode = "MOBILE"
			enableMobileESP()
		end
	else
		currentESPMode = "MOBILE"
		enableMobileESP()
	end
end
local function disableESPUnified()
	if currentESPMode == "PC" then
		pc_disable()
	elseif currentESPMode == "MOBILE" then
		disableMobileESP()
	else
		-- try both
		pc_disable()
		disableMobileESP()
	end
end

-- ESP button press
espBtn.MouseButton1Click:Connect(function()
	local turningOn = (espBtn.Text:find("off") ~= nil)
	if turningOn then
		espBtn.Text = "esp: on"
		espBtn.BackgroundColor3 = ACCENT
		enableESPUnified()
	else
		espBtn.Text = "esp: off"
		espBtn.BackgroundColor3 = PANEL
		disableESPUnified()
	end
end)

-- ========================
-- Helper: isBehindTarget (unchanged)
-- ========================
local function isBehindTarget(hrp, targetHRP)
	local distance = (hrp.Position - targetHRP.Position).Magnitude
	if distance > range then return false end
	if mode == "Around" then return true end
	local direction = -targetHRP.CFrame.LookVector
	local toPlayer = (hrp.Position - targetHRP.Position)
	return toPlayer:Dot(direction) > 0.5
end

-- ========================
-- Main Backstab Loop (Quad tween keeps behavior)
-- ========================
RunService.Heartbeat:Connect(function()
	if not enabled or cooldown then return end
	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
	local hrp = char.HumanoidRootPart

	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			local kHRP = killer.HumanoidRootPart
			if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
				cooldown = true
				lastTarget = killer
				local start = tick()
				local didDagger = false
				local connection
				connection = RunService.Heartbeat:Connect(function()
					if not (char and char.Parent and kHRP and kHRP.Parent) then
						if connection then connection:Disconnect() end
						return
					end
					local elapsed = tick() - start
					if elapsed >= 0.5 then
						if connection then connection:Disconnect() end
						return
					end
					-- tween behind target (Quad easing)
					local behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 0.3)
					local targetCFrame = CFrame.new(behindPos, behindPos + kHRP.CFrame.LookVector)
					local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
					local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
					tween:Play()
					-- align look + dagger once
					if not didDagger then
						didDagger = true
						local faceStart = tick()
						local faceConn
						faceConn = RunService.Heartbeat:Connect(function()
							if tick() - faceStart >= 0.7 or not kHRP or not kHRP.Parent then
								if faceConn then faceConn:Disconnect() end
								return
							end
							hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + kHRP.CFrame.LookVector)
						end)
						pcall(function() daggerRemote:FireServer("UseActorAbility", "Dagger") end)
					end
				end)
				task.delay(2, function()
					RunService.Heartbeat:Wait()
					while isBehindTarget(hrp, kHRP) do
						RunService.Heartbeat:Wait()
					end
					lastTarget = nil
					cooldown = false
				end)
				break
			end
		end
	end
end)

-- ========================
-- End of script
-- ========================

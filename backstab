-- MOCKS' BACKSTAB SCRIPT + Exunys ESP toggle
-- Standalone LocalScript for StarterPlayerScripts
-- NOTE: This fetches Exunys ESP from GitHub (requires HttpGet + loadstring support).

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local camera = workspace.CurrentCamera

local lp = Players.LocalPlayer

-- ======= Config / Defaults =======
local DEFAULTS = {
    updateRate = 0.033,
    tracerSmoothing = 0.45,
    posSmoothing = 0.45,
    tracerThickness = 2,
    healthBarWidth = 6,
    healthGapPx = 3,
    tracerOriginOffset = 36,
    tweenDuration = 0.20,
    boxWidthRatio = 0.45,
}

-- Remote (safe pcall)
local daggerRemote
pcall(function()
    daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

-- Killer list (color red)
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killerSet = {}
for _,n in ipairs(killerNames) do killerSet[n] = true end

-- ESP state persisted per session
getgenv().ESP_SETTINGS = getgenv().ESP_SETTINGS or {
    -- these are the toggles shown in the GUI; Exunys' ESP will be toggled by the single esp button
    boxes = false,
    filled = false,
    outline = false,
    names = false,
    distance = false,
    health = false,
    tracers = false,
    crosshair = false,
    keepOnDeath = true,
    updateRate = DEFAULTS.updateRate,
}
local ESP = getgenv().ESP_SETTINGS

-- Backstab state
local enabled = false
local cooldown = false
local lastTarget = nil
local range = ESP.range or 4.0
local mode = ESP.mode or "behind"

-- Visual constants
local WHITE = Color3.fromRGB(255,255,255)
local SURV_COLOR = WHITE
local KILLER_COLOR = Color3.fromRGB(255,80,80)

-- GUI colors & geometry
local BG_COLOR = Color3.fromRGB(37,40,45)
local PANEL_COLOR = Color3.fromRGB(42,45,50)
local ACCENT_COLOR = Color3.fromRGB(56,63,76)
local BTN_OFF = Color3.fromRGB(95,95,100)
local BTN_ON  = Color3.fromRGB(120,120,140)
local TITLE_COLOR = Color3.fromRGB(200,200,200)

local MAIN_W, MAIN_H = 540, 300
local MAIN_X, MAIN_Y = 10, 10
local OFF_Y = -350

-- small helpers
local function lerp(a,b,t) return a + (b-a)*t end
local function lerpVec(a,b,t) return a:Lerp(b,t) end

-- ======= GUI Build =======
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MocksBackstabGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
mainFrame.Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
mainFrame.Visible = false

local outlineStroke = Instance.new("UIStroke", mainFrame)
outlineStroke.Color = ACCENT_COLOR
outlineStroke.Thickness = 3

local titleBar = Instance.new("Frame", mainFrame)
titleBar.Size = UDim2.new(1,0,0,28)
titleBar.Position = UDim2.new(0,0,0,0)
titleBar.BackgroundColor3 = Color3.fromRGB(60,60,67)
titleBar.BorderSizePixel = 0

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1, -12, 1, 0)
titleText.Position = UDim2.new(0, 6, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "MOCKS'  BACKSTAB  SCRIPT"
titleText.Font = Enum.Font.Code
titleText.TextSize = 14
titleText.TextColor3 = TITLE_COLOR
titleText.TextXAlignment = Enum.TextXAlignment.Left

local topDivider = Instance.new("Frame", mainFrame)
topDivider.Size = UDim2.new(1, -12, 0, 6)
topDivider.Position = UDim2.new(0, 6, 0, 28)
topDivider.BackgroundColor3 = ACCENT_COLOR
topDivider.BorderSizePixel = 0

local leftPanel = Instance.new("Frame", mainFrame)
leftPanel.Size = UDim2.new(0, 170, 1, -40)
leftPanel.Position = UDim2.new(0, 6, 0, 36)
leftPanel.BackgroundColor3 = PANEL_COLOR
leftPanel.BorderSizePixel = 0

local midSep = Instance.new("Frame", mainFrame)
midSep.Size = UDim2.new(0, 6, 1, -40)
midSep.Position = UDim2.new(0, 180, 0, 36)
midSep.BackgroundColor3 = ACCENT_COLOR
midSep.BorderSizePixel = 0

local rightPanel = Instance.new("Frame", mainFrame)
rightPanel.Size = UDim2.new(0, 358, 1, -40)
rightPanel.Position = UDim2.new(0, 192, 0, 36)
rightPanel.BackgroundColor3 = PANEL_COLOR
rightPanel.BorderSizePixel = 0

local innerTop = Instance.new("Frame", mainFrame)
innerTop.Size = UDim2.new(1, -12, 0, 6)
innerTop.Position = UDim2.new(0, 6, 0, 32)
innerTop.BackgroundColor3 = ACCENT_COLOR
innerTop.BorderSizePixel = 0

-- button maker
local function makeBtn(parent, size, pos, text)
    local b = Instance.new("TextButton")
    b.Size = size
    b.Position = pos
    b.BackgroundColor3 = BTN_OFF
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Code
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(20,20,20)
    b.Text = text
    b.AutoButtonColor = false
    b.Parent = parent
    return b
end

-- left controls
local backstabBtn = makeBtn(leftPanel, UDim2.new(0,150,0,28), UDim2.new(0,8,0,8), "backstab: off")
local rangeLabel = Instance.new("TextLabel", leftPanel)
rangeLabel.Size = UDim2.new(0,150,0,18)
rangeLabel.Position = UDim2.new(0,8,0,42)
rangeLabel.BackgroundTransparency = 1
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.TextColor3 = TITLE_COLOR
rangeLabel.Text = ("range: %.1f"):format(range)
rangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local sliderBg = Instance.new("Frame", leftPanel)
sliderBg.Size = UDim2.new(0,150,0,12)
sliderBg.Position = UDim2.new(0,8,0,64)
sliderBg.BackgroundColor3 = Color3.fromRGB(60,60,65)
sliderBg.BorderSizePixel = 0
local sliderFill = Instance.new("Frame", sliderBg)
sliderFill.Size = UDim2.new((range - 1)/9, 0, 1, 0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = Color3.fromRGB(110,110,120)
sliderFill.BorderSizePixel = 0
local sliderKnob = Instance.new("TextButton", sliderBg)
sliderKnob.Size = UDim2.new(0,12,0,12)
sliderKnob.Position = UDim2.new((range - 1)/9, -6, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(30,30,30)
sliderKnob.BorderSizePixel = 0
sliderKnob.AutoButtonColor = false
sliderKnob.Text = ""
local modeBtn = makeBtn(leftPanel, UDim2.new(0,150,0,24), UDim2.new(0,8,0,92), ("mode:%s"):format(mode))

-- right side flow (two rows)
local buttonWidth, buttonHeight, paddingX, paddingY = 120, 28, 8, 8
local startX, startY = 8, 8
local columns = 2
local function flowPos(index)
    local col = ((index-1) % columns)
    local row = math.floor((index-1) / columns)
    return UDim2.new(0, startX + col*(buttonWidth + paddingX), 0, startY + row*(buttonHeight + paddingY))
end

-- RIGHT BUTTONS: keep them but the main Exunys ESP will be toggled with the single button below (espBtn)
local rightButtons = {
    { key = "boxes",   label = function(v) return ("boxes:%s"):format(v and "on" or "off") end },
    { key = "filled",  label = function(v) return ("fill:%s"):format(v and "on" or "off") end },
    { key = "outline", label = function(v) return ("outline:%s"):format(v and "on" or "off") end },
    { key = "names",   label = function(v) return ("names:%s"):format(v and "on" or "off") end },
    { key = "distance",label = function(v) return ("distance:%s"):format(v and "on" or "off") end },
    { key = "health",  label = function(v) return ("health:%s"):format(v and "on" or "off") end },
    { key = "tracers", label = function(v) return ("tracers:%s"):format(v and "on" or "off") end },
    { key = "crosshair", label = function(v) return ("crosshair:%s"):format(v and "on" or "off") end },
}

local rightBtnsInstances = {}
for i,info in ipairs(rightButtons) do
    local pos = flowPos(i)
    local inst = makeBtn(rightPanel, UDim2.new(0,buttonWidth,0,buttonHeight), pos, info.label(ESP[info.key]))
    rightBtnsInstances[info.key] = inst
end

-- The single Exunys toggle button (placed where the old esp button sat)
local espBtn = makeBtn(rightPanel, UDim2.new(0,buttonWidth,0,buttonHeight), flowPos(1), ("esp: %s"):format("off"))
espBtn.Position = flowPos(9) -- place it after the other toggles, or change index to desired slot
espBtn.Text = ("esp: %s"):format("off") -- lowercase per your request

-- helper to set button visuals
local function updateBtnVisual(btn, on) btn.BackgroundColor3 = on and BTN_ON or BTN_OFF end

-- GUI visibility toggling (RightShift)
local guiVisible = false
local function slideIn()
    mainFrame.Visible = true
    TweenService:Create(mainFrame, TweenInfo.new(0.38, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, MAIN_X, 0, MAIN_Y)
    }):Play()
end
local function slideOut()
    local t = TweenService:Create(mainFrame, TweenInfo.new(0.30, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
    })
    t:Play()
    t.Completed:Connect(function()
        if not guiVisible then mainFrame.Visible = false end
    end)
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        guiVisible = not guiVisible
        if guiVisible then slideIn() else slideOut() end
    end
end)

-- slider logic
local dragging = false
local function setSliderFromX(x)
    local absPos = sliderBg.AbsolutePosition.X
    local absSize = sliderBg.AbsoluteSize.X
    local localX = math.clamp(x - absPos, 0, absSize)
    local pct = (absSize > 0) and (localX / absSize) or 0
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderKnob.Position = UDim2.new(pct, -6, 0, 0)
    range = 1 + pct * 9
    rangeLabel.Text = ("range: %.1f"):format(range)
    ESP.range = range
    getgenv().ESP_SETTINGS = ESP
end

sliderKnob.MouseButton1Down:Connect(function() dragging = true end)
UserInputService.InputChanged:Connect(function(inp)
    if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then setSliderFromX(inp.Position.X) end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

-- left buttons behavior
backstabBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
    updateBtnVisual(backstabBtn, enabled)
end)
modeBtn.MouseButton1Click:Connect(function()
    if mode == "behind" then mode = "around" else mode = "behind" end
    modeBtn.Text = ("mode:%s"):format(mode)
    ESP.mode = mode
    getgenv().ESP_SETTINGS = ESP
end)

-- connect right side small toggles (these only update local ESP settings, Exunys ESP will be toggled separately)
for _,info in ipairs(rightButtons) do
    local key = info.key
    local btn = rightBtnsInstances[key]
    btn.MouseButton1Click:Connect(function()
        ESP[key] = not ESP[key]
        btn.Text = info.label(ESP[key])
        updateBtnVisual(btn, ESP[key])
        getgenv().ESP_SETTINGS = ESP
    end)
    updateBtnVisual(btn, ESP[key])
end

updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)

-- ======= Exunys loader / toggler =======
local EXUNYS_RAW_URL = "https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"
local exunysInstance = nil
local exunys_source_cache = nil
local exunys_enabled = false

local function tryCleanupExunys()
    -- attempt common cleanup methods
    local ok
    if exunysInstance then
        -- common patterns: module returns table with Destroy/Stop/Disable
        pcall(function()
            if type(exunysInstance.Destroy) == "function" then exunysInstance.Destroy(exunysInstance) end
        end)
        pcall(function()
            if type(exunysInstance.Stop) == "function" then exunysInstance.Stop(exunysInstance) end
        end)
        pcall(function()
            if type(exunysInstance.Disable) == "function" then exunysInstance.Disable(exunysInstance) end
        end)
    end
    -- many ESP modules set globals; attempt to clear some known global names
    pcall(function() getgenv().Exunys = nil end)
    pcall(function() getgenv().ESP = nil end)
    pcall(function() getgenv().ESP_MODULE = nil end)
    -- try to clear Drawing cache if exposed
    pcall(function()
        if typeof(cleardrawcache) == "function" then cleardrawcache()
        elseif rawget(_G, "Cleardrawcache") then pcall(rawget(_G, "Cleardrawcache")) end
    end)
    exunysInstance = nil
end

local function loadAndStartExunys()
    -- If source cached, reuse; otherwise attempt HttpGet
    local src = exunys_source_cache
    if not src then
        local ok, res = pcall(function()
            -- prefer exploit's HttpGet
            if type(game.HttpGet) == "function" then
                return game:HttpGet(EXUNYS_RAW_URL)
            elseif type(game.HttpGetAsync) == "function" then
                return game:HttpGetAsync(EXUNYS_RAW_URL)
            else
                error("HttpGet not available")
            end
        end)
        if not ok or not res then
            warn("[ExunysLoader] failed to download Exunys ESP:", res)
            return false
        end
        src = res
        exunys_source_cache = src
    end

    -- execute source with loadstring (exploit environments provide loadstring)
    local ok2, result = pcall(function()
        if type(loadstring) ~= "function" then
            -- some environments provide loadstring under different name or use load; try load
            if type(load) == "function" then
                return load(src)()
            else
                error("loadstring/load not available")
            end
        else
            return loadstring(src)()
        end
    end)
    if not ok2 then
        warn("[ExunysLoader] failed to execute Exunys ESP:", result)
        return false
    end
    -- many scripts return a table or set globals; capture returned instance if any
    exunysInstance = result
    return true
end

-- esp button click: toggle Exunys on/off
espBtn.MouseButton1Click:Connect(function()
    if not exunys_enabled then
        -- turn ON
        local ok = loadAndStartExunys()
        if ok then
            exunys_enabled = true
            espBtn.Text = ("esp: %s"):format("on")
            updateBtnVisual(espBtn, true)
        else
            espBtn.Text = ("esp: %s"):format("off")
            updateBtnVisual(espBtn, false)
        end
    else
        -- turn OFF: attempt to cleanup gracefully
        tryCleanupExunys()
        exunys_enabled = false
        espBtn.Text = ("esp: %s"):format("off")
        updateBtnVisual(espBtn, false)
    end
end)

-- ======= Overlay/backstab/etc (kept from your last working script) =======
-- Create only the local overlays needed for backstab UI, backstab detection, and tweening.
-- (For brevity, this section implements the tween-behind-and-stab and candidate selection logic.
--  The Exunys ESP draws its own overlays; small GUI toggles above control preferences saved in getgenv.)

local function tweenBehindAndStab(targetHRP, duration)
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = lp.Character.HumanoidRootPart
    if not (targetHRP and targetHRP.Parent) then return end

    local behindOffset = 0.6
    local behindPos = targetHRP.Position - (targetHRP.CFrame.LookVector * behindOffset)
    local targetCFrame = CFrame.new(behindPos, behindPos + targetHRP.CFrame.LookVector)

    local ok, tween = pcall(function()
        return TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { CFrame = targetCFrame })
    end)
    if not ok or not tween then
        pcall(function()
            hrp.CFrame = targetCFrame
            if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end
        end)
        return
    end

    tween:Play()
    local conn
    conn = tween.Completed:Connect(function()
        if conn then conn:Disconnect() end
        if not (targetHRP and targetHRP.Parent) then return end
        if hrp and hrp.Parent then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + targetHRP.CFrame.LookVector) end
        pcall(function() if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end end)
    end)

    task.delay(duration + 0.1, function()
        if conn and conn.Connected then conn:Disconnect() end
    end)
end

-- isBehindTarget logic preserved
function isBehindTarget(hrp, targetHRP)
    local dist = (hrp.Position - targetHRP.Position).Magnitude
    if dist > range then return false end
    if mode == "around" then return true end
    local direction = -targetHRP.CFrame.LookVector
    local toPlayer = (hrp.Position - targetHRP.Position)
    return toPlayer:Dot(direction) > 0.5
end

-- Backstab detection loop (keeps previous behavior)
RunService.RenderStepped:Connect(function()
    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = char.HumanoidRootPart

    -- Build list of candidate targets
    local killersToCheck = {}
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, nm in ipairs(killerNames) do
            local k = killersFolder:FindFirstChild(nm)
            if k and k:FindFirstChild("HumanoidRootPart") then table.insert(killersToCheck, k) end
        end
    end
    if #killersToCheck == 0 then
        for _, other in ipairs(Players:GetPlayers()) do
            if other ~= lp and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(killersToCheck, other.Character)
            end
        end
    end

    for _, kobj in ipairs(killersToCheck) do
        local kHRP = kobj and kobj:FindFirstChild("HumanoidRootPart")
        if kHRP then
            if enabled and not cooldown and isBehindTarget(hrp, kHRP) and kobj ~= lastTarget then
                cooldown = true
                lastTarget = kobj
                tweenBehindAndStab(kHRP, DEFAULTS.tweenDuration)
                task.delay(2, function()
                    RunService.Heartbeat:Wait()
                    while isBehindTarget(hrp, kHRP) do RunService.Heartbeat:Wait() end
                    lastTarget = nil
                    cooldown = false
                end)
                break
            end
        end
    end
end)

-- final UI text init
for _,info in ipairs(rightButtons) do
    local key = info.key
    if rightBtnsInstances[key] then
        rightBtnsInstances[key].Text = info.label(ESP[key])
        updateBtnVisual(rightBtnsInstances[key], ESP[key])
    end
end
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)
modeBtn.Text = ("mode:%s"):format(mode)

getgenv().ESP_SETTINGS = ESP

-- End of LocalScript

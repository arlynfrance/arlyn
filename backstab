-- MOCKS' BACKSTAB SCRIPT (with in-place Exunys ESP toggle)
-- Standalone LocalScript for StarterPlayerScripts
-- Loads Exunys' ESP from raw GitHub when toggled on; attempts best-effort cleanup when toggled off.
-- Source URL: https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local camera = workspace.CurrentCamera

local lp = Players.LocalPlayer

-- (Backstab / dagger remote handling â€” preserve your behavior)
local daggerRemote
pcall(function()
    daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

-- basic backstab state (keeps your original control)
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 4.0
local mode = "behind"

-- Exunys ESP raw URL (we load this exact resource at runtime)
local EXUNYS_ESP_URL = "https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"

-- persistent session settings
getgenv().ESP_SETTINGS = getgenv().ESP_SETTINGS or {
    esp_enabled = false,
    range = range,
    mode = mode,
}
local ESP = getgenv().ESP_SETTINGS
range = ESP.range or range
mode = ESP.mode or mode

-- ----------------- GUI (keeps your layout, RightShift opens) -----------------
local BG_COLOR = Color3.fromRGB(37,40,45)
local PANEL_COLOR = Color3.fromRGB(42,45,50)
local ACCENT_COLOR = Color3.fromRGB(56,63,76)
local BTN_OFF = Color3.fromRGB(95,95,100)
local BTN_ON  = Color3.fromRGB(120,120,140)
local TITLE_COLOR = Color3.fromRGB(200,200,200)

local MAIN_W, MAIN_H = 540, 300
local MAIN_X, MAIN_Y = 10, 10
local OFF_Y = -350

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MocksBackstabGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
mainFrame.Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
mainFrame.Visible = false

local outlineStroke = Instance.new("UIStroke", mainFrame)
outlineStroke.Color = ACCENT_COLOR
outlineStroke.Thickness = 3

local titleBar = Instance.new("Frame", mainFrame)
titleBar.Size = UDim2.new(1,0,0,28)
titleBar.Position = UDim2.new(0,0,0,0)
titleBar.BackgroundColor3 = Color3.fromRGB(60,60,67)
titleBar.BorderSizePixel = 0

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1, -12, 1, 0)
titleText.Position = UDim2.new(0, 6, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "MOCKS' BACKSTAB SCRIPT"
titleText.Font = Enum.Font.Code
titleText.TextSize = 14
titleText.TextColor3 = TITLE_COLOR
titleText.TextXAlignment = Enum.TextXAlignment.Left

local topDivider = Instance.new("Frame", mainFrame)
topDivider.Size = UDim2.new(1, -12, 0, 6)
topDivider.Position = UDim2.new(0, 6, 0, 28)
topDivider.BackgroundColor3 = ACCENT_COLOR
topDivider.BorderSizePixel = 0

-- left panel (backstab controls)
local leftPanel = Instance.new("Frame", mainFrame)
leftPanel.Size = UDim2.new(0, 170, 1, -40)
leftPanel.Position = UDim2.new(0, 6, 0, 36)
leftPanel.BackgroundColor3 = PANEL_COLOR
leftPanel.BorderSizePixel = 0

local midSep = Instance.new("Frame", mainFrame)
midSep.Size = UDim2.new(0, 6, 1, -40)
midSep.Position = UDim2.new(0, 180, 0, 36)
midSep.BackgroundColor3 = ACCENT_COLOR
midSep.BorderSizePixel = 0

-- rightPanel where the single esp toggle sits (replaces old multiple esp buttons)
local rightPanel = Instance.new("Frame", mainFrame)
rightPanel.Size = UDim2.new(0, 170, 1, -40)
rightPanel.Position = UDim2.new(0, 192, 0, 36)
rightPanel.BackgroundColor3 = PANEL_COLOR
rightPanel.BorderSizePixel = 0

-- small button helper
local function makeBtn(parent, posY, text)
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(0, 120, 0, 28)
    b.Position = UDim2.new(0, 8, 0, posY)
    b.BackgroundColor3 = BTN_OFF
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Code
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(20,20,20)
    b.Text = text
    b.AutoButtonColor = false
    b.Parent = parent
    return b
end

local backstabBtn = makeBtn(leftPanel, 8, "backstab: off")
local rangeLabel = Instance.new("TextLabel", leftPanel)
rangeLabel.Size = UDim2.new(0, 150, 0, 18)
rangeLabel.Position = UDim2.new(0, 8, 0, 42)
rangeLabel.BackgroundTransparency = 1
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.TextColor3 = TITLE_COLOR
rangeLabel.Text = ("range: %.1f"):format(range)
rangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local sliderBg = Instance.new("Frame", leftPanel)
sliderBg.Size = UDim2.new(0, 150, 0, 12)
sliderBg.Position = UDim2.new(0, 8, 0, 64)
sliderBg.BackgroundColor3 = Color3.fromRGB(60,60,65)
sliderBg.BorderSizePixel = 0

local sliderFill = Instance.new("Frame", sliderBg)
sliderFill.Size = UDim2.new((range - 1) / 9, 0, 1, 0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = Color3.fromRGB(110,110,120)
sliderFill.BorderSizePixel = 0

local sliderKnob = Instance.new("TextButton", sliderBg)
sliderKnob.Size = UDim2.new(0, 12, 0, 12)
sliderKnob.Position = UDim2.new((range - 1) / 9, -6, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(30,30,30)
sliderKnob.BorderSizePixel = 0
sliderKnob.AutoButtonColor = false
sliderKnob.Text = ""

local modeBtn = makeBtn(leftPanel, 92, ("mode:%s"):format(mode))

-- THE single Exunys ESP toggle (replaces all old esp buttons)
local exunysBtn = makeBtn(rightPanel, 8, ("esp: %s"):format(ESP.esp_enabled and "on" or "off"))

-- slider behavior
local dragging = false
local function setSliderFromX(x)
    local absPos = sliderBg.AbsolutePosition.X
    local absSize = sliderBg.AbsoluteSize.X
    local localX = math.clamp(x - absPos, 0, absSize)
    local pct = (absSize > 0) and (localX / absSize) or 0
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderKnob.Position = UDim2.new(pct, -6, 0, 0)
    range = 1 + pct * 9
    rangeLabel.Text = ("range: %.1f"):format(range)
    ESP.range = range
    getgenv().ESP_SETTINGS = ESP
end

sliderKnob.MouseButton1Down:Connect(function() dragging = true end)
UserInputService.InputChanged:Connect(function(inp)
    if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then setSliderFromX(inp.Position.X) end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

-- GUI open/close with RightShift
local guiVisible = false
local function slideIn()
    mainFrame.Visible = true
    TweenService:Create(mainFrame, TweenInfo.new(0.38, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, MAIN_X, 0, MAIN_Y)
    }):Play()
end
local function slideOut()
    local t = TweenService:Create(mainFrame, TweenInfo.new(0.30, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
    })
    t:Play()
    t.Completed:Connect(function()
        if not guiVisible then mainFrame.Visible = false end
    end)
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        guiVisible = not guiVisible
        if guiVisible then slideIn() else slideOut() end
    end
end)

-- small helper to change button visuals
local function updateBtnVisual(btn, on)
    btn.BackgroundColor3 = on and BTN_ON or BTN_OFF
end

-- backstab button
backstabBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
    updateBtnVisual(backstabBtn, enabled)
end)
modeBtn.MouseButton1Click:Connect(function()
    mode = (mode == "behind") and "around" or "behind"
    modeBtn.Text = ("mode:%s"):format(mode)
    ESP.mode = mode
    getgenv().ESP_SETTINGS = ESP
end)

-- ----------------- Exunys ESP loader / toggler -----------------
-- We'll load the upstream script exactly at runtime so we don't have to copy-paste it here.
-- Best-effort removal/cleanup is attempted on toggle off.
local EXUNYS_INSTANCE = nil
local EXUNYS_LOAD_SUCCESS = false

local function try_cleanup_exunys()
    -- Try various common cleanup calls that well-behaved modules expose.
    -- We don't assume anything, so wrap each in pcall.
    if not EXUNYS_INSTANCE then
        -- try clearing drawing cache if available
        if cleardrawcache then
            pcall(function() cleardrawcache() end)
        end
        return
    end

    local inst = EXUNYS_INSTANCE

    -- common names
    local attempts = {
        function() if type(inst.Unload) == "function" then inst:Unload() return true end end,
        function() if type(inst.Destroy) == "function" then inst:Destroy() return true end end,
        function() if type(inst.Disable) == "function" then inst:Disable() return true end end,
        function() if type(inst.Toggle) == "function" then inst:Toggle(false) return true end end,
        function() if type(inst.SetEnabled) == "function" then inst:SetEnabled(false) return true end end,
        function() if type(inst.DestroyAll) == "function" then inst:DestroyAll() return true end end,
    }

    for _,fn in ipairs(attempts) do
        local ok, res = pcall(fn)
        if ok and res then
            -- cleanup succeeded via that API
            EXUNYS_INSTANCE = nil
            return true
        end
    end

    -- fallback: if module returned a table with references to drawings / objects, attempt to nil them
    pcall(function()
        for k,v in pairs(inst) do
            if type(v) == "table" then
                for kk,vv in pairs(v) do
                    if typeof(vv) == "Instance" and vv.Parent then
                        pcall(function() vv:Destroy() end)
                    end
                end
            end
        end
    end)

    -- clear any drawing caches if function exists
    pcall(function() if cleardrawcache then cleardrawcache() end end)

    EXUNYS_INSTANCE = nil
    return true
end

local function load_exunys_esp()
    -- load remote file and execute it; return the module's return if any
    local ok, result = pcall(function()
        -- Use HttpGet (some executors require the second argument true)
        local source = nil
        -- try a few variations to be robust to executor differences
        local tries = {
            function() return game:HttpGet(EXUNYS_ESP_URL, true) end,
            function() return game:HttpGet(EXUNYS_ESP_URL) end,
            function() return (syn and syn.request and syn.request{ Url = EXUNYS_ESP_URL, Method = "GET" }.Body) end,
        }
        for _,fn in ipairs(tries) do
            local ok2, res = pcall(fn)
            if ok2 and type(res) == "string" and #res > 10 then
                source = res
                break
            end
        end
        if not source then error("Failed to download Exunys ESP. Check HTTP permissions or executor.") end

        -- run the code in a sandbox; prefer loadstring if available
        local loaded, chunk = pcall(loadstring, source)
        if not loaded or not chunk then error("Failed to compile Exunys ESP code") end

        -- execute and capture return (many modules return a table)
        local ret = nil
        local status, rv = pcall(function() return chunk() end)
        if status then ret = rv end
        return ret
    end)
    if ok then
        EXUNYS_INSTANCE = result
        EXUNYS_LOAD_SUCCESS = true
        return true, result
    else
        EXUNYS_LOAD_SUCCESS = false
        warn("Exunys ESP load failed:", result)
        return false, result
    end
end

-- Toggle handler for the Exunys button
exunysBtn.MouseButton1Click:Connect(function()
    ESP.esp_enabled = not ESP.esp_enabled
    exunysBtn.Text = ("esp: %s"):format(ESP.esp_enabled and "on" or "off")
    updateBtnVisual(exunysBtn, ESP.esp_enabled)
    getgenv().ESP_SETTINGS = ESP

    if ESP.esp_enabled then
        -- load remote ESP (exact upstream code)
        local ok, ret = load_exunys_esp()
        if not ok then
            warn("Failed to load Exunys ESP:", ret)
            -- revert toggle
            ESP.esp_enabled = false
            exunysBtn.Text = ("esp: %s"):format("off")
            updateBtnVisual(exunysBtn, false)
            getgenv().ESP_SETTINGS = ESP
        end
    else
        -- try to cleanup the loaded module
        local cleaned = pcall(try_cleanup_exunys)
        if not cleaned then
            warn("Exunys cleanup attempted but may not have removed everything.")
        end
    end
end)

-- initialize visuals
updateBtnVisual(exunysBtn, ESP.esp_enabled)
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)
modeBtn.Text = ("mode:%s"):format(mode)

-- ----------------- Original backstab detection logic (keeps behavior) -----------------
local function isBehindTarget(hrp, targetHRP)
    local dist = (hrp.Position - targetHRP.Position).Magnitude
    if dist > range then return false end
    if mode == "around" then return true end
    local direction = -targetHRP.CFrame.LookVector
    local toPlayer = (hrp.Position - targetHRP.Position)
    return toPlayer:Dot(direction) > 0.5
end

local function tweenBehindAndStab(targetHRP, duration)
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = lp.Character.HumanoidRootPart
    if not (targetHRP and targetHRP.Parent) then return end

    local behindOffset = 0.6
    local behindPos = targetHRP.Position - (targetHRP.CFrame.LookVector * behindOffset)
    local targetCFrame = CFrame.new(behindPos, behindPos + targetHRP.CFrame.LookVector)

    local ok, tween = pcall(function()
        return TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { CFrame = targetCFrame })
    end)
    if not ok or not tween then
        pcall(function()
            hrp.CFrame = targetCFrame
            if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end
        end)
        return
    end

    tween:Play()
    local conn
    conn = tween.Completed:Connect(function()
        if conn then conn:Disconnect() end
        if not (targetHRP and targetHRP.Parent) then return end
        if hrp and hrp.Parent then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + targetHRP.CFrame.LookVector) end
        pcall(function() if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end end)
    end)

    task.delay(duration + 0.1, function()
        if conn and conn.Connected then conn:Disconnect() end
    end)
end

-- Main run loop (keeps original detection and auto-backstab)
RunService.RenderStepped:Connect(function()
    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = char.HumanoidRootPart

    -- Candidate targets
    local killersToCheck = {}
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, nm in ipairs({"Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli"}) do
            local k = killersFolder:FindFirstChild(nm)
            if k and k:FindFirstChild("HumanoidRootPart") then table.insert(killersToCheck, k) end
        end
    end
    if #killersToCheck == 0 then
        for _, other in ipairs(Players:GetPlayers()) do
            if other ~= lp and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(killersToCheck, other.Character)
            end
        end
    end

    for _, kobj in ipairs(killersToCheck) do
        local kHRP = kobj and kobj:FindFirstChild("HumanoidRootPart")
        if kHRP then
            if enabled and not cooldown and isBehindTarget(hrp, kHRP) and kobj ~= lastTarget then
                cooldown = true
                lastTarget = kobj

                tweenBehindAndStab(kHRP, 0.20)

                task.delay(2, function()
                    RunService.Heartbeat:Wait()
                    while isBehindTarget(hrp, kHRP) do RunService.Heartbeat:Wait() end
                    lastTarget = nil
                    cooldown = false
                end)

                break
            end
        end
    end
end)

-- End of script

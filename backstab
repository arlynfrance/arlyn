-- MOCKS' BACKSTAB SCRIPT + Exunys ESP loader toggle
-- Place as LocalScript in StarterPlayerScripts

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local camera = workspace.CurrentCamera

local lp = Players.LocalPlayer

-- ======= Config / Defaults =======
local DEFAULTS = {
    updateRate = 0.033,
    tracerSmoothing = 0.45,
    posSmoothing = 0.45,
    tracerThickness = 2,
    healthBarWidth = 6,
    healthGapPx = 3,
    tracerOriginOffset = 36,
    tweenDuration = 0.20,
    boxWidthRatio = 0.45,
}

-- Remote (safe pcall)
local daggerRemote
pcall(function()
    daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

-- Killer list (color red)
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killerSet = {}
for _,n in ipairs(killerNames) do killerSet[n] = true end

-- ESP state persisted per session
getgenv().ESP_SETTINGS = getgenv().ESP_SETTINGS or {
    boxes = false,
    filled = false,
    outline = false,
    names = false,
    distance = false,
    health = false,
    tracers = false,
    crosshair = false,
    keepOnDeath = true,
    updateRate = DEFAULTS.updateRate,
}
local ESP = getgenv().ESP_SETTINGS

-- Backstab state (keeps original behavior)
local enabled = false
local cooldown = false
local lastTarget = nil
local range = ESP.range or 4.0
local mode = ESP.mode or "behind"

-- Visual constants (white theme)
local WHITE = Color3.fromRGB(255,255,255)
local SURV_COLOR = WHITE
local KILLER_COLOR = Color3.fromRGB(255,80,80)

-- GUI colors & geometry (keeps style)
local BG_COLOR = Color3.fromRGB(37,40,45)
local PANEL_COLOR = Color3.fromRGB(42,45,50)
local ACCENT_COLOR = Color3.fromRGB(56,63,76)
local BTN_OFF = Color3.fromRGB(95,95,100)
local BTN_ON  = Color3.fromRGB(120,120,140)
local TITLE_COLOR = Color3.fromRGB(200,200,200)

local MAIN_W, MAIN_H = 540, 300
local MAIN_X, MAIN_Y = 10, 10
local OFF_Y = -350

-- ======= Exunys ESP URL & loader state =======
local EXUNYS_URL = "https://raw.githubusercontent.com/Exunys/Exunys-ESP/main/src/ESP.lua"
local exunys_loaded = false
local exunys_handle = nil  -- possible returned controller/table from the script
local exunys_raw_source = nil

-- Helper lerp
local function lerp(a,b,t) return a + (b-a)*t end
local function lerpVector(a,b,t) return a:Lerp(b,t) end

-- ======= GUI Build (your GUI, ESP toggle where old esp button was) =======
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MocksBackstabGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
mainFrame.Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
mainFrame.Visible = false

local outlineStroke = Instance.new("UIStroke", mainFrame)
outlineStroke.Color = ACCENT_COLOR
outlineStroke.Thickness = 3

local titleBar = Instance.new("Frame", mainFrame)
titleBar.Size = UDim2.new(1,0,0,28)
titleBar.Position = UDim2.new(0,0,0,0)
titleBar.BackgroundColor3 = Color3.fromRGB(60,60,67)
titleBar.BorderSizePixel = 0

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1, -12, 1, 0)
titleText.Position = UDim2.new(0, 6, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "MOCKS'  BACKSTAB  SCRIPT"
titleText.Font = Enum.Font.Code
titleText.TextSize = 14
titleText.TextColor3 = TITLE_COLOR
titleText.TextXAlignment = Enum.TextXAlignment.Left

local topDivider = Instance.new("Frame", mainFrame)
topDivider.Size = UDim2.new(1, -12, 0, 6)
topDivider.Position = UDim2.new(0, 6, 0, 28)
topDivider.BackgroundColor3 = ACCENT_COLOR
topDivider.BorderSizePixel = 0

local leftPanel = Instance.new("Frame", mainFrame)
leftPanel.Size = UDim2.new(0, 170, 1, -40)
leftPanel.Position = UDim2.new(0, 6, 0, 36)
leftPanel.BackgroundColor3 = PANEL_COLOR
leftPanel.BorderSizePixel = 0

local midSep = Instance.new("Frame", mainFrame)
midSep.Size = UDim2.new(0, 6, 1, -40)
midSep.Position = UDim2.new(0, 180, 0, 36)
midSep.BackgroundColor3 = ACCENT_COLOR
midSep.BorderSizePixel = 0

local rightPanel = Instance.new("Frame", mainFrame)
rightPanel.Size = UDim2.new(0, 358, 1, -40)
rightPanel.Position = UDim2.new(0, 192, 0, 36)
rightPanel.BackgroundColor3 = PANEL_COLOR
rightPanel.BorderSizePixel = 0

local innerTop = Instance.new("Frame", mainFrame)
innerTop.Size = UDim2.new(1, -12, 0, 6)
innerTop.Position = UDim2.new(0, 6, 0, 32)
innerTop.BackgroundColor3 = ACCENT_COLOR
innerTop.BorderSizePixel = 0

-- small button maker
local function makeBtn(parent, size, pos, text)
    local b = Instance.new("TextButton")
    b.Size = size
    b.Position = pos
    b.BackgroundColor3 = BTN_OFF
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Code
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(20,20,20)
    b.Text = text
    b.AutoButtonColor = false
    b.Parent = parent
    return b
end

-- left controls (backstab and slider)
local backstabBtn = makeBtn(leftPanel, UDim2.new(0,150,0,28), UDim2.new(0,8,0,8), "backstab: off")
local rangeLabel = Instance.new("TextLabel", leftPanel)
rangeLabel.Size = UDim2.new(0,150,0,18)
rangeLabel.Position = UDim2.new(0,8,0,42)
rangeLabel.BackgroundTransparency = 1
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.TextColor3 = TITLE_COLOR
rangeLabel.Text = ("range: %.1f"):format(range)
rangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local sliderBg = Instance.new("Frame", leftPanel)
sliderBg.Size = UDim2.new(0,150,0,12)
sliderBg.Position = UDim2.new(0,8,0,64)
sliderBg.BackgroundColor3 = Color3.fromRGB(60,60,65)
sliderBg.BorderSizePixel = 0
local sliderFill = Instance.new("Frame", sliderBg)
sliderFill.Size = UDim2.new((range - 1)/9, 0, 1, 0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = Color3.fromRGB(110,110,120)
sliderFill.BorderSizePixel = 0
local sliderKnob = Instance.new("TextButton", sliderBg)
sliderKnob.Size = UDim2.new(0,12,0,12)
sliderKnob.Position = UDim2.new((range - 1)/9, -6, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(30,30,30)
sliderKnob.BorderSizePixel = 0
sliderKnob.AutoButtonColor = false
sliderKnob.Text = ""
local modeBtn = makeBtn(leftPanel, UDim2.new(0,150,0,24), UDim2.new(0,8,0,92), ("mode:%s"):format(mode))

-- right side buttons (flow)
local buttonWidth, buttonHeight, paddingX, paddingY = 120, 28, 8, 8
local startX, startY = 8, 8
local columns = 2
local function flowPos(index)
    local col = ((index-1) % columns)
    local row = math.floor((index-1) / columns)
    return UDim2.new(0, startX + col*(buttonWidth + paddingX), 0, startY + row*(buttonHeight + paddingY))
end

local rightButtons = {
    { key = "boxes",   label = function(v) return ("boxes:%s"):format(v and "on" or "off") end },
    { key = "filled",  label = function(v) return ("fill:%s"):format(v and "on" or "off") end },
    { key = "outline", label = function(v) return ("outline:%s"):format(v and "on" or "off") end },
    { key = "names",   label = function(v) return ("names:%s"):format(v and "on" or "off") end },
    { key = "distance",label = function(v) return ("distance:%s"):format(v and "on" or "off") end },
    { key = "health",  label = function(v) return ("health:%s"):format(v and "on" or "off") end },
    { key = "tracers", label = function(v) return ("tracers:%s"):format(v and "on" or "off") end },
    { key = "crosshair", label = function(v) return ("crosshair:%s"):format(v and "on" or "off") end },
}

local rightBtnsInstances = {}
for i,info in ipairs(rightButtons) do
    local pos = flowPos(i)
    local inst = makeBtn(rightPanel, UDim2.new(0,buttonWidth,0,buttonHeight), pos, info.label(ESP[info.key]))
    rightBtnsInstances[info.key] = inst
end

local function updateBtnVisual(btn, on) btn.BackgroundColor3 = on and BTN_ON or BTN_OFF end

-- GUI visibility toggling (RightShift)
local guiVisible = false
local function slideIn()
    mainFrame.Visible = true
    TweenService:Create(mainFrame, TweenInfo.new(0.38, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, MAIN_X, 0, MAIN_Y)
    }):Play()
end
local function slideOut()
    local t = TweenService:Create(mainFrame, TweenInfo.new(0.30, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
    })
    t:Play()
    t.Completed:Connect(function()
        if not guiVisible then mainFrame.Visible = false end
    end)
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        guiVisible = not guiVisible
        if guiVisible then slideIn() else slideOut() end
    end
end)

-- slider logic
local dragging = false
local function setSliderFromX(x)
    local absPos = sliderBg.AbsolutePosition.X
    local absSize = sliderBg.AbsoluteSize.X
    local localX = math.clamp(x - absPos, 0, absSize)
    local pct = (absSize > 0) and (localX / absSize) or 0
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderKnob.Position = UDim2.new(pct, -6, 0, 0)
    range = 1 + pct * 9
    rangeLabel.Text = ("range: %.1f"):format(range)
    ESP.range = range
    getgenv().ESP_SETTINGS = ESP
end

sliderKnob.MouseButton1Down:Connect(function() dragging = true end)
UserInputService.InputChanged:Connect(function(inp)
    if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then setSliderFromX(inp.Position.X) end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

-- left buttons behavior
backstabBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
    updateBtnVisual(backstabBtn, enabled)
end)
modeBtn.MouseButton1Click:Connect(function()
    if mode == "behind" then mode = "around" else mode = "behind" end
    modeBtn.Text = ("mode:%s"):format(mode)
    ESP.mode = mode
    getgenv().ESP_SETTINGS = ESP
end)

-- connect right side toggle buttons (these are local options; Exunys script is loaded/controlled by the dedicated esp toggle below)
for _,info in ipairs(rightButtons) do
    local key = info.key
    local btn = rightBtnsInstances[key]
    btn.MouseButton1Click:Connect(function()
        ESP[key] = not ESP[key]
        btn.Text = info.label(ESP[key])
        updateBtnVisual(btn, ESP[key])
        getgenv().ESP_SETTINGS = ESP
    end)
    updateBtnVisual(btn, ESP[key])
end

-- ensure backstab visual init
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)

-- ======= Overlay placeholders (kept in script so old features remain intact) =======
local overlayFolder = Instance.new("Folder", screenGui)
overlayFolder.Name = "ESPOverlays"

-- NOTE: we are replacing the old box/skeleton implementation with Exunys' ESP when user toggles it on.
-- The local ESP toggles (boxes/names/tracers) control session flags; the actual Exunys script will use its own logic.

-- ======= Exunys ESP loader & toggler =======
-- Robust HTTP GET function using common environments
local function httpGet(url)
    -- Try several common exploit/runtime functions then fall back to HttpService
    local ok, res

    -- syn.request
    if type(syn) == "table" and syn.request then
        ok, res = pcall(function() return syn.request({ Url = url, Method = "GET" }).Body end)
        if ok and res then return res end
    end

    -- http.request (Fluxus / etc)
    if type(http) == "table" and http.request then
        ok, res = pcall(function() return http.request({ Url = url, Method = "GET" }).Body end)
        if ok and res then return res end
    end

    -- request (older)
    if type(request) == "function" then
        ok, res = pcall(function() return request({ Url = url, Method = "GET" }).Body end)
        if ok and res then return res end
    end

    -- game:HttpGet (roblox)
    if type(game.HttpGet) == "function" then
        ok, res = pcall(function() return game:HttpGet(url) end)
        if ok and res then return res end
    end

    -- HttpService:GetAsync (requires HttpEnabled)
    ok, res = pcall(function() return HttpService:GetAsync(url) end)
    if ok and res then return res end

    return nil, "http get failed"
end

local function try_disable_exunys()
    -- Try multiple common cleanup interfaces the remote script might expose
    -- 1) if exunys_handle is a table with common functions, call them
    if exunys_handle then
        pcall(function()
            if type(exunys_handle.Toggle) == "function" then exunys_handle.Toggle(false) end
            if type(exunys_handle.Disable) == "function" then exunys_handle.Disable() end
            if type(exunys_handle.Unload) == "function" then exunys_handle.Unload() end
            if type(exunys_handle.Destroy) == "function" then exunys_handle.Destroy() end
            if type(exunys_handle.Stop) == "function" then exunys_handle.Stop() end
        end)
    end

    -- 2) check getgenv/_G for common globals
    pcall(function()
        if getgenv and getgenv().ExunysESP and type(getgenv().ExunysESP.Destroy) == "function" then
            getgenv().ExunysESP.Destroy()
        end
        if getgenv and getgenv().ESP and type(getgenv().ESP.Disable) == "function" then
            getgenv().ESP.Disable()
        end
        if _G and _G.ExunysESP and type(_G.ExunysESP.Destroy) == "function" then
            _G.ExunysESP.Destroy()
        end
        if _G and _G.ESP and type(_G.ESP.Disable) == "function" then
            _G.ESP.Disable()
        end
    end)

    -- 3) remove likely GUI containers created by remote script (best-effort)
    pcall(function()
        -- common names: "ESP", "Exunys-ESP", "ExunysESP", "ESPGui"
        local candidates = {
            screenGui:FindFirstChild("ESP"),
            screenGui:FindFirstChild("ExunysESP"),
            screenGui:FindFirstChild("Exunys-ESP"),
            screenGui:FindFirstChild("ESPGui"),
            Players.LocalPlayer:FindFirstChild("PlayerGui") and Players.LocalPlayer.PlayerGui:FindFirstChild("ESP"),
        }
        for _,c in ipairs(candidates) do
            if c and c.Parent then pcall(function() c:Destroy() end) end
        end
        -- also check CoreGui (if remote used CoreGui)
        if game:FindService("CoreGui") then
            for _,name in ipairs({"ESP","ExunysESP","Exunys-ESP","ESPGui"}) do
                local cg = false
                pcall(function() cg = game.CoreGui:FindFirstChild(name) end)
                if cg and cg.Parent then pcall(function() cg:Destroy() end) end
            end
        end
    end)

    -- 4) clear reference
    exunys_loaded = false
    exunys_handle = nil
end

local function load_exunys_script_once()
    if exunys_loaded then return true end

    local source, err = httpGet(EXUNYS_URL)
    if not source then
        warn("Failed to fetch Exunys ESP:", err)
        return false, err
    end

    exunys_raw_source = source

    -- Run the fetched code in a sandboxed environment with getgenv exposed (so the remote script can persist)
    local fn, loadErr = loadstring(source)
    if not fn then
        warn("Failed to load Exunys ESP source:", loadErr)
        return false, loadErr
    end

    -- Protected call to execute script
    local ok, ret = pcall(function()
        return fn()
    end)
    if not ok then
        warn("Exunys ESP runtime error:", ret)
        return false, ret
    end

    -- If the script returned a controller table, store it
    if type(ret) == "table" then
        exunys_handle = ret
    else
        -- try to detect common global placements
        exunys_handle = getgenv().ExunysESP or getgenv().ESP or _G.ExunysESP or _G.ESP or ret
    end

    exunys_loaded = true
    return true
end

-- Dedicated ESP toggle button (replaces old esp system)
-- Find the original "esp button spot" â€” we're using the rightBtnsInstances['boxes'] placement earlier.
-- But user asked specifically to have a single button toggle Exunys's script where the old ESP button was.
-- We'll add an "espToggleBtn" in that spot (we'll reuse the 'boxes' button instance)
local espToggleBtn = rightBtnsInstances["boxes"]
if not espToggleBtn then
    -- fallback: create small button at top-left of rightPanel
    espToggleBtn = makeBtn(rightPanel, UDim2.new(0,120,0,28), UDim2.new(0,8,0,8), "esp: off")
    rightBtnsInstances["boxes"] = espToggleBtn
end

-- Initialize label lowercase
local function setEspBtnState(on)
    espToggleBtn.Text = ("esp: %s"):format(on and "on" or "off")
    updateBtnVisual(espToggleBtn, on)
end
setEspBtnState(false)

-- Toggle behavior
espToggleBtn.MouseButton1Click:Connect(function()
    -- If not loaded, try to load and run the remote script
    if not exunys_loaded then
        local ok, err = load_exunys_script_once()
        if not ok then
            -- failed: show feedback and keep it off
            setEspBtnState(false)
            warn("Exunys ESP load failed:", err)
            return
        end
        -- If loaded, try to enable it (if the remote script exposes Toggle or Enable)
        local enabledNow = true
        local toggled = false
        pcall(function()
            if exunys_handle and type(exunys_handle.Toggle) == "function" then
                exunys_handle.Toggle(true)
                toggled = true
            elseif exunys_handle and type(exunys_handle.Enable) == "function" then
                exunys_handle.Enable(true)
                toggled = true
            elseif getgenv().ExunysESP and type(getgenv().ExunysESP.Toggle) == "function" then
                getgenv().ExunysESP.Toggle(true)
                toggled = true
            elseif getgenv().ESP and type(getgenv().ESP.Toggle) == "function" then
                getgenv().ESP.Toggle(true)
                toggled = true
            end
        end)
        -- If remote didn't provide toggle, we assume running the script enabled visuals.
        exunys_loaded = true
        setEspBtnState(enabledNow)
    else
        -- attempt to disable/unload
        try_disable_exunys()
        setEspBtnState(false)
    end
end)

-- ======= Backstab/Tween logic (keeps prior behavior) =======
local function worldToScreen(vec3)
    local p, on = camera:WorldToViewportPoint(vec3)
    return Vector2.new(p.X, p.Y), on
end

local function projectBounds(rootPart)
    if not rootPart then return nil end
    local topWorld = rootPart.Position + Vector3.new(0, 2.4, 0)
    local botWorld = rootPart.Position + Vector3.new(0, -1.0, 0)
    local top2, topOn = worldToScreen(topWorld)
    local bot2, botOn = worldToScreen(botWorld)
    return top2, bot2, (topOn or botOn), topWorld, botWorld
end

local function getHealthPercent(char)
    if not char then return nil end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health and humanoid.MaxHealth and humanoid.MaxHealth > 0 then
        return math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
    end
    return nil
end

local function isR6(char)
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.RigType == Enum.HumanoidRigType.R6
end

local function tweenBehindAndStab(targetHRP, duration)
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = lp.Character.HumanoidRootPart
    if not (targetHRP and targetHRP.Parent) then return end

    local behindOffset = 0.6
    local behindPos = targetHRP.Position - (targetHRP.CFrame.LookVector * behindOffset)
    local targetCFrame = CFrame.new(behindPos, behindPos + targetHRP.CFrame.LookVector)

    local ok, tween = pcall(function()
        return TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { CFrame = targetCFrame })
    end)
    if not ok or not tween then
        pcall(function()
            hrp.CFrame = targetCFrame
            if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end
        end)
        return
    end

    tween:Play()
    local conn
    conn = tween.Completed:Connect(function()
        if conn then conn:Disconnect() end
        if not (targetHRP and targetHRP.Parent) then return end
        if hrp and hrp.Parent then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + targetHRP.CFrame.LookVector) end
        pcall(function() if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end end)
    end)

    task.delay(duration + 0.1, function()
        if conn and conn.Connected then conn:Disconnect() end
    end)
end

-- isBehindTarget (original logic)
function isBehindTarget(hrp, targetHRP)
    local dist = (hrp.Position - targetHRP.Position).Magnitude
    if dist > range then return false end
    if mode == "around" then return true end
    local direction = -targetHRP.CFrame.LookVector
    local toPlayer = (hrp.Position - targetHRP.Position)
    return toPlayer:Dot(direction) > 0.5
end

-- ======= Main loop for backstab detection (RenderStepped) =======
RunService.RenderStepped:Connect(function()
    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = char.HumanoidRootPart

    -- Build list of candidate targets: prefer workspace.Players.Killers, else other players' characters
    local killersToCheck = {}
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, nm in ipairs(killerNames) do
            local k = killersFolder:FindFirstChild(nm)
            if k and k:FindFirstChild("HumanoidRootPart") then table.insert(killersToCheck, k) end
        end
    end
    if #killersToCheck == 0 then
        for _, other in ipairs(Players:GetPlayers()) do
            if other ~= lp and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(killersToCheck, other.Character)
            end
        end
    end

    for _, kobj in ipairs(killersToCheck) do
        local kHRP = kobj and kobj:FindFirstChild("HumanoidRootPart")
        if kHRP then
            if enabled and not cooldown and isBehindTarget(hrp, kHRP) and kobj ~= lastTarget then
                cooldown = true
                lastTarget = kobj

                tweenBehindAndStab(kHRP, DEFAULTS.tweenDuration)

                task.delay(2, function()
                    RunService.Heartbeat:Wait()
                    while isBehindTarget(hrp, kHRP) do RunService.Heartbeat:Wait() end
                    lastTarget = nil
                    cooldown = false
                end)

                break
            end
        end
    end
end)

-- Persist GUI text & visuals on start
for _,info in ipairs(rightButtons) do
    local key = info.key
    if rightBtnsInstances[key] then
        rightBtnsInstances[key].Text = info.label(ESP[info.key])
        updateBtnVisual(rightBtnsInstances[key], ESP[info.key])
    end
end
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)

getgenv().ESP_SETTINGS = ESP

-- Final note: if the remote Exunys script changes API, the loader uses many fallbacks to try to toggle/unload it.
-- If you want a guaranteed programmatic 'off', modify the remote script to expose a known "Destroy" or "Toggle" function and
-- return it at the end so this loader can call it.

print("Mocks' Backstab + Exunys loader script initialized.")

-- MOCKS' BACKSTAB SCRIPT
-- Standalone LocalScript for StarterPlayerScripts
-- R6-only Exunys-style ESP (white) + GUI toggles + smooth bottom-center tracers + tween-behind-then-stab

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local camera = workspace.CurrentCamera

local lp = Players.LocalPlayer

-- ======= Config / Defaults =======
local DEFAULTS = {
    updateRate = 0.033,          -- seconds per visual update (~30 FPS)
    tracerSmoothing = 0.45,      -- 0..1 lerp factor for tracer smoothing (higher = snappier)
    posSmoothing = 0.45,         -- smoothing for name/box position
    tracerThickness = 2,
    healthBarWidth = 6,
    healthGapPx = 3,             -- 3px gap between box and health bar
    tracerOriginOffset = 36,     -- bottom center offset in px
    tweenDuration = 0.20,        -- time to tween behind then stab
    boxWidthRatio = 0.45,        -- box width relative to height
}

-- Remote (safe pcall)
local daggerRemote
pcall(function()
    daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

-- Killer list (color red)
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killerSet = {}
for _,n in ipairs(killerNames) do killerSet[n] = true end

-- ESP state persisted per session
getgenv().ESP_SETTINGS = getgenv().ESP_SETTINGS or {
    boxes = false,
    filled = false,
    outline = false,
    names = false,
    distance = false,
    health = false,
    tracers = false,
    crosshair = false,
    keepOnDeath = true,
    updateRate = DEFAULTS.updateRate,
}
local ESP = getgenv().ESP_SETTINGS

-- Backstab state (keeps original behavior)
local enabled = false
local cooldown = false
local lastTarget = nil
local range = ESP.range or 4.0
local mode = ESP.mode or "behind"

-- Visual constants (white theme)
local WHITE = Color3.fromRGB(255,255,255)
local SURV_COLOR = WHITE
local KILLER_COLOR = Color3.fromRGB(255,80,80)

-- GUI colors & geometry (keeps style)
local BG_COLOR = Color3.fromRGB(37,40,45)
local PANEL_COLOR = Color3.fromRGB(42,45,50)
local ACCENT_COLOR = Color3.fromRGB(56,63,76)
local BTN_OFF = Color3.fromRGB(95,95,100)
local BTN_ON  = Color3.fromRGB(120,120,140)
local TITLE_COLOR = Color3.fromRGB(200,200,200)

local MAIN_W, MAIN_H = 540, 300
local MAIN_X, MAIN_Y = 10, 10
local OFF_Y = -350

-- Helper lerp
local function lerp(a,b,t) return a + (b-a)*t end
local function lerpVector(a,b,t) return a:Lerp(b,t) end

-- ======= GUI Build =======
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MocksBackstabGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, MAIN_W, 0, MAIN_H)
mainFrame.Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
mainFrame.BackgroundColor3 = BG_COLOR
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
mainFrame.Visible = false

local outlineStroke = Instance.new("UIStroke", mainFrame)
outlineStroke.Color = ACCENT_COLOR
outlineStroke.Thickness = 3

local titleBar = Instance.new("Frame", mainFrame)
titleBar.Size = UDim2.new(1,0,0,28)
titleBar.Position = UDim2.new(0,0,0,0)
titleBar.BackgroundColor3 = Color3.fromRGB(60,60,67)
titleBar.BorderSizePixel = 0

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1, -12, 1, 0)
titleText.Position = UDim2.new(0, 6, 0, 0)
titleText.BackgroundTransparency = 1
titleText.Text = "MOCKS'  BACKSTAB  SCRIPT"
titleText.Font = Enum.Font.Code
titleText.TextSize = 14
titleText.TextColor3 = TITLE_COLOR
titleText.TextXAlignment = Enum.TextXAlignment.Left

local topDivider = Instance.new("Frame", mainFrame)
topDivider.Size = UDim2.new(1, -12, 0, 6)
topDivider.Position = UDim2.new(0, 6, 0, 28)
topDivider.BackgroundColor3 = ACCENT_COLOR
topDivider.BorderSizePixel = 0

local leftPanel = Instance.new("Frame", mainFrame)
leftPanel.Size = UDim2.new(0, 170, 1, -40)
leftPanel.Position = UDim2.new(0, 6, 0, 36)
leftPanel.BackgroundColor3 = PANEL_COLOR
leftPanel.BorderSizePixel = 0

local midSep = Instance.new("Frame", mainFrame)
midSep.Size = UDim2.new(0, 6, 1, -40)
midSep.Position = UDim2.new(0, 180, 0, 36)
midSep.BackgroundColor3 = ACCENT_COLOR
midSep.BorderSizePixel = 0

local rightPanel = Instance.new("Frame", mainFrame)
rightPanel.Size = UDim2.new(0, 358, 1, -40) -- expand right panel so two-row flow fits
rightPanel.Position = UDim2.new(0, 192, 0, 36)
rightPanel.BackgroundColor3 = PANEL_COLOR
rightPanel.BorderSizePixel = 0

local innerTop = Instance.new("Frame", mainFrame)
innerTop.Size = UDim2.new(1, -12, 0, 6)
innerTop.Position = UDim2.new(0, 6, 0, 32)
innerTop.BackgroundColor3 = ACCENT_COLOR
innerTop.BorderSizePixel = 0

-- button maker (we'll arrange in flowing two rows inside rightPanel)
local function makeBtn(parent, size, pos, text)
    local b = Instance.new("TextButton")
    b.Size = size
    b.Position = pos
    b.BackgroundColor3 = BTN_OFF
    b.BorderSizePixel = 0
    b.Font = Enum.Font.Code
    b.TextSize = 14
    b.TextColor3 = Color3.fromRGB(20,20,20)
    b.Text = text
    b.AutoButtonColor = false
    b.Parent = parent
    return b
end

-- left controls (backstab and slider)
local backstabBtn = makeBtn(leftPanel, UDim2.new(0,150,0,28), UDim2.new(0,8,0,8), "backstab: off")
local rangeLabel = Instance.new("TextLabel", leftPanel)
rangeLabel.Size = UDim2.new(0,150,0,18)
rangeLabel.Position = UDim2.new(0,8,0,42)
rangeLabel.BackgroundTransparency = 1
rangeLabel.Font = Enum.Font.Code
rangeLabel.TextSize = 14
rangeLabel.TextColor3 = TITLE_COLOR
rangeLabel.Text = ("range: %.1f"):format(range)
rangeLabel.TextXAlignment = Enum.TextXAlignment.Left

local sliderBg = Instance.new("Frame", leftPanel)
sliderBg.Size = UDim2.new(0,150,0,12)
sliderBg.Position = UDim2.new(0,8,0,64)
sliderBg.BackgroundColor3 = Color3.fromRGB(60,60,65)
sliderBg.BorderSizePixel = 0
local sliderFill = Instance.new("Frame", sliderBg)
sliderFill.Size = UDim2.new((range - 1)/9, 0, 1, 0)
sliderFill.Position = UDim2.new(0,0,0,0)
sliderFill.BackgroundColor3 = Color3.fromRGB(110,110,120)
sliderFill.BorderSizePixel = 0
local sliderKnob = Instance.new("TextButton", sliderBg)
sliderKnob.Size = UDim2.new(0,12,0,12)
sliderKnob.Position = UDim2.new((range - 1)/9, -6, 0, 0)
sliderKnob.BackgroundColor3 = Color3.fromRGB(30,30,30)
sliderKnob.BorderSizePixel = 0
sliderKnob.AutoButtonColor = false
sliderKnob.Text = ""
local modeBtn = makeBtn(leftPanel, UDim2.new(0,150,0,24), UDim2.new(0,8,0,92), ("mode:%s"):format(mode))

-- right side: flow two rows (we place types in order, flowing left->right then wrap)
local buttonWidth, buttonHeight, paddingX, paddingY = 120, 28, 8, 8
local startX, startY = 8, 8
local columns = 2
local function flowPos(index)
    local col = ((index-1) % columns)
    local row = math.floor((index-1) / columns)
    return UDim2.new(0, startX + col*(buttonWidth + paddingX), 0, startY + row*(buttonHeight + paddingY))
end

local rightButtons = {
    { key = "boxes",   label = function(v) return ("boxes:%s"):format(v and "on" or "off") end },
    { key = "filled",  label = function(v) return ("fill:%s"):format(v and "on" or "off") end },
    { key = "outline", label = function(v) return ("outline:%s"):format(v and "on" or "off") end },
    { key = "names",   label = function(v) return ("names:%s"):format(v and "on" or "off") end },
    { key = "distance",label = function(v) return ("distance:%s"):format(v and "on" or "off") end },
    { key = "health",  label = function(v) return ("health:%s"):format(v and "on" or "off") end },
    { key = "tracers", label = function(v) return ("tracers:%s"):format(v and "on" or "off") end },
    { key = "crosshair", label = function(v) return ("crosshair:%s"):format(v and "on" or "off") end },
}

local rightBtnsInstances = {}
for i,info in ipairs(rightButtons) do
    local pos = flowPos(i)
    local inst = makeBtn(rightPanel, UDim2.new(0,buttonWidth,0,buttonHeight), pos, info.label(ESP[info.key]))
    rightBtnsInstances[info.key] = inst
end

-- helper to update visuals
local function updateBtnVisual(btn, on) btn.BackgroundColor3 = on and BTN_ON or BTN_OFF end

-- GUI visibility toggling (RightShift)
local guiVisible = false
local function slideIn()
    mainFrame.Visible = true
    TweenService:Create(mainFrame, TweenInfo.new(0.38, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
        Position = UDim2.new(0, MAIN_X, 0, MAIN_Y)
    }):Play()
end
local function slideOut()
    local t = TweenService:Create(mainFrame, TweenInfo.new(0.30, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
        Position = UDim2.new(0, MAIN_X, 0, OFF_Y)
    })
    t:Play()
    t.Completed:Connect(function()
        if not guiVisible then mainFrame.Visible = false end
    end)
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.RightShift then
        guiVisible = not guiVisible
        if guiVisible then slideIn() else slideOut() end
    end
end)

-- slider logic
local dragging = false
local function setSliderFromX(x)
    local absPos = sliderBg.AbsolutePosition.X
    local absSize = sliderBg.AbsoluteSize.X
    local localX = math.clamp(x - absPos, 0, absSize)
    local pct = (absSize > 0) and (localX / absSize) or 0
    sliderFill.Size = UDim2.new(pct, 0, 1, 0)
    sliderKnob.Position = UDim2.new(pct, -6, 0, 0)
    range = 1 + pct * 9
    rangeLabel.Text = ("range: %.1f"):format(range)
    ESP.range = range
    getgenv().ESP_SETTINGS = ESP
end

sliderKnob.MouseButton1Down:Connect(function() dragging = true end)
UserInputService.InputChanged:Connect(function(inp)
    if dragging and inp.UserInputType == Enum.UserInputType.MouseMovement then setSliderFromX(inp.Position.X) end
end)
UserInputService.InputEnded:Connect(function(inp)
    if inp.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
end)

-- left buttons behavior
backstabBtn.MouseButton1Click:Connect(function()
    enabled = not enabled
    backstabBtn.Text = "backstab: " .. (enabled and "on" or "off")
    updateBtnVisual(backstabBtn, enabled)
end)
modeBtn.MouseButton1Click:Connect(function()
    if mode == "behind" then mode = "around" else mode = "behind" end
    modeBtn.Text = ("mode:%s"):format(mode)
    ESP.mode = mode
    getgenv().ESP_SETTINGS = ESP
end)

-- connect right side toggle buttons
for _,info in ipairs(rightButtons) do
    local key = info.key
    local btn = rightBtnsInstances[key]
    btn.MouseButton1Click:Connect(function()
        ESP[key] = not ESP[key]
        btn.Text = info.label(ESP[key])
        updateBtnVisual(btn, ESP[key])
        getgenv().ESP_SETTINGS = ESP
    end)
    updateBtnVisual(btn, ESP[key])
end

-- ensure backstab visual init
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)

-- ======= Overlay objects & pools (always on top via ZIndex) =======
local overlayFolder = Instance.new("Folder", screenGui)
overlayFolder.Name = "ESPOverlays"

-- tables keyed by player.Name
local boxes = {}
local nameLabels = {}
local distLabels = {}
local healthBars = {}
local tracers = {}
local smoothedPos = {}   -- Vector2 smoothed screen pos for box centers
local smoothedTracerEnd = {} -- Vector2 smoothed end pos for tracers

-- create overlay elements
local function createBox(name)
    local con = Instance.new("Frame")
    con.Name = "Box_" .. name
    con.Size = UDim2.new(0,60,0,120)
    con.Position = UDim2.new(0,0,0,0)
    con.BackgroundTransparency = 1
    con.BorderSizePixel = 0
    con.ZIndex = 10
    con.Parent = overlayFolder

    local fill = Instance.new("Frame", con)
    fill.Name = "Fill"
    fill.Size = UDim2.new(1,0,1,0)
    fill.Position = UDim2.new(0,0,0,0)
    fill.BackgroundColor3 = WHITE
    fill.BackgroundTransparency = 1
    fill.BorderSizePixel = 0
    fill.ZIndex = 11

    local border = Instance.new("Frame", con)
    border.Name = "Border"
    border.Size = UDim2.new(1,0,1,0)
    border.Position = UDim2.new(0,0,0,0)
    border.BackgroundTransparency = 1
    border.BorderSizePixel = 0
    border.ZIndex = 11

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = DEFAULTS.tracerThickness -- will override below
    stroke.Parent = border
    stroke.Color = WHITE
    stroke.Thickness = DEFAULTS.tracerThickness
    stroke.Enabled = ESP.outline

    return con
end

local function createNameLabel(name)
    local lbl = Instance.new("TextLabel")
    lbl.Name = "Name_" .. name
    lbl.Size = UDim2.new(0,200,0,20)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Code
    lbl.TextSize = 16
    lbl.TextColor3 = WHITE
    lbl.Text = name
    lbl.ZIndex = 12
    lbl.Parent = overlayFolder
    return lbl
end

local function createDistLabel(name)
    local lbl = Instance.new("TextLabel")
    lbl.Name = "Dist_" .. name
    lbl.Size = UDim2.new(0,80,0,16)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Code
    lbl.TextSize = 14
    lbl.TextColor3 = WHITE
    lbl.Text = ""
    lbl.ZIndex = 12
    lbl.Parent = overlayFolder
    return lbl
end

local function createHealthBar(name)
    local bg = Instance.new("Frame")
    bg.Name = "Health_" .. name
    bg.Size = UDim2.new(0, DEFAULTS.healthBarWidth, 0, 40)
    bg.BackgroundColor3 = Color3.fromRGB(25,25,25)
    bg.BorderSizePixel = 0
    bg.ZIndex = 11
    bg.Parent = overlayFolder

    local fill = Instance.new("Frame", bg)
    fill.Name = "Fill"
    fill.Size = UDim2.new(1,0,1,0)
    fill.Position = UDim2.new(0,0,0,0)
    fill.BackgroundColor3 = WHITE
    fill.BorderSizePixel = 0
    fill.ZIndex = 12
    return bg
end

local function createTracer(name)
    local t = Instance.new("Frame")
    t.Name = "Tracer_" .. name
    t.Size = UDim2.new(0, 0, 0, DEFAULTS.tracerThickness)
    t.BackgroundColor3 = WHITE
    t.BorderSizePixel = 0
    t.AnchorPoint = Vector2.new(0, 0.5)
    t.ZIndex = 9
    t.Parent = overlayFolder
    return t
end

local function createCrosshair()
    local g = Instance.new("Folder")
    g.Name = "Crosshair"
    g.Parent = overlayFolder
    local size = 10
    local v = Instance.new("Frame", g)
    v.Size = UDim2.new(0, 1, 0, size)
    v.Position = UDim2.new(0.5, -0.5, 0.5, -math.floor(size/2))
    v.BackgroundColor3 = WHITE
    v.BorderSizePixel = 0
    v.ZIndex = 13
    local h = Instance.new("Frame", g)
    h.Size = UDim2.new(0, size, 0, 1)
    h.Position = UDim2.new(0.5, -math.floor(size/2), 0.5, -0.5)
    h.BackgroundColor3 = WHITE
    h.BorderSizePixel = 0
    h.ZIndex = 13
    return g
end

local crossGui = nil

-- cleanup when player leaves
Players.PlayerRemoving:Connect(function(plr) 
    removeAllFor = function(name) -- quick local reuse
        if boxes[name] and boxes[name].Parent then boxes[name]:Destroy() end; boxes[name] = nil
        if nameLabels[name] and nameLabels[name].Parent then nameLabels[name]:Destroy() end; nameLabels[name] = nil
        if distLabels[name] and distLabels[name].Parent then distLabels[name]:Destroy() end; distLabels[name] = nil
        if healthBars[name] and healthBars[name].Parent then healthBars[name]:Destroy() end; healthBars[name] = nil
        if tracers[name] and tracers[name].Parent then tracers[name]:Destroy() end; tracers[name] = nil
        smoothedPos[name] = nil
        smoothedTracerEnd[name] = nil
    end
    removeAllFor(plr.Name)
end)

-- ======= Utility functions =======
local function worldToScreen(vec3)
    local p, on = camera:WorldToViewportPoint(vec3)
    return Vector2.new(p.X, p.Y), on
end

local function projectBounds(rootPart)
    if not rootPart then return nil end
    local topWorld = rootPart.Position + Vector3.new(0, 2.4, 0)
    local botWorld = rootPart.Position + Vector3.new(0, -1.0, 0)
    local top2, topOn = worldToScreen(topWorld)
    local bot2, botOn = worldToScreen(botWorld)
    return top2, bot2, (topOn or botOn), topWorld, botWorld
end

local function getHealthPercent(char)
    if not char then return nil end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health and humanoid.MaxHealth and humanoid.MaxHealth > 0 then
        return math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
    end
    return nil
end

-- R6 check
local function isR6(char)
    if not char then return false end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.RigType == Enum.HumanoidRigType.R6
end

-- ======= Tween behind and stab (keeps behavior) =======
local function tweenBehindAndStab(targetHRP, duration)
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local hrp = lp.Character.HumanoidRootPart
    if not (targetHRP and targetHRP.Parent) then return end

    local behindOffset = 0.6
    local behindPos = targetHRP.Position - (targetHRP.CFrame.LookVector * behindOffset)
    local targetCFrame = CFrame.new(behindPos, behindPos + targetHRP.CFrame.LookVector)

    local ok, tween = pcall(function()
        return TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), { CFrame = targetCFrame })
    end)
    if not ok or not tween then
        pcall(function()
            hrp.CFrame = targetCFrame
            if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end
        end)
        return
    end

    tween:Play()
    local conn
    conn = tween.Completed:Connect(function()
        if conn then conn:Disconnect() end
        if not (targetHRP and targetHRP.Parent) then return end
        if hrp and hrp.Parent then hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + targetHRP.CFrame.LookVector) end
        pcall(function() if daggerRemote then daggerRemote:FireServer("UseActorAbility", "Dagger") end end)
    end)

    task.delay(duration + 0.1, function()
        if conn and conn.Connected then conn:Disconnect() end
    end)
end

-- ======= Main update loop (throttled) =======
local accumulator = 0
RunService.RenderStepped:Connect(function(dt)
    accumulator = accumulator - dt
    if accumulator > 0 then return end
    accumulator = ESP.updateRate or DEFAULTS.updateRate

    local char = lp.Character
    if not (char and char:FindFirstChild("HumanoidRootPart")) then
        -- cleanup overlays
        for name,_ in pairs(boxes) do
            if boxes[name] and boxes[name].Parent then boxes[name]:Destroy() end
            boxes[name] = nil
            if nameLabels[name] and nameLabels[name].Parent then nameLabels[name]:Destroy() end
            nameLabels[name] = nil
            if distLabels[name] and distLabels[name].Parent then distLabels[name]:Destroy() end
            distLabels[name] = nil
            if healthBars[name] and healthBars[name].Parent then healthBars[name]:Destroy() end
            healthBars[name] = nil
            if tracers[name] and tracers[name].Parent then tracers[name]:Destroy() end
            tracers[name] = nil
        end
        if crossGui and crossGui.Parent then crossGui.Parent = nil end
        return
    end

    local hrp = char.HumanoidRootPart

    -- crosshair
    if ESP.crosshair then
        if not crossGui then crossGui = createCrosshair() end
        if crossGui.Parent ~= overlayFolder then crossGui.Parent = overlayFolder end
    else
        if crossGui and crossGui.Parent then crossGui.Parent = nil end
    end

    -- iterate other players
    for _,other in ipairs(Players:GetPlayers()) do
        if other ~= lp then
            local otherChar = other.Character
            local isR6Char = isR6(otherChar)
            -- require R6 (or keep overlay if keepOnDeath and char exists)
            if isR6Char or (ESP.keepOnDeath and otherChar) then
                -- find main root (R6 HumanoidRootPart or Torso)
                local root = otherChar and (otherChar:FindFirstChild("HumanoidRootPart") or otherChar:FindFirstChild("Torso") or otherChar:FindFirstChild("UpperTorso"))
                local name = other.Name
                local color = killerSet[name] and KILLER_COLOR or SURV_COLOR

                -- compute bounds
                local top2, bot2, ons, topWorld, botWorld = projectBounds(root)
                local onsScreen = ons and top2 and bot2

                -- initialize smoothing tables
                if not smoothedPos[name] then smoothedPos[name] = top2 or Vector2.new(0,0) end
                if not smoothedTracerEnd[name] then smoothedTracerEnd[name] = bot2 or Vector2.new(0,0) end

                -- target positions (use top2 for name anchor, and bottom center for tracer end)
                local targetTop = top2 or smoothedPos[name]
                local targetBot = bot2 or smoothedTracerEnd[name]

                -- smooth positions
                smoothedPos[name] = smoothedPos[name] and lerpVector(smoothedPos[name], targetTop, DEFAULTS.posSmoothing) or targetTop
                smoothedTracerEnd[name] = smoothedTracerEnd[name] and lerpVector(smoothedTracerEnd[name], targetBot, DEFAULTS.tracerSmoothing) or targetBot

                -- BOXES
                if ESP.boxes then
                    if not boxes[name] then
                        boxes[name] = createBox(name)
                    end
                    local box = boxes[name]
                    if ons and top2 and bot2 then
                        local height = math.max(18, math.abs(top2.Y - bot2.Y))
                        local width = math.max(10, math.floor(height * DEFAULTS.boxWidthRatio))
                        -- center at top2.X (top of box is top2.Y)
                        box.Size = UDim2.new(0, width, 0, height)
                        box.Position = UDim2.new(0, top2.X - (width/2), 0, top2.Y)
                        box.Visible = true
                        -- fill
                        local fill = box:FindFirstChild("Fill")
                        if fill then
                            fill.BackgroundTransparency = ESP.filled and (1 - BOX_FILL_ALPHA) or 1
                            fill.BackgroundColor3 = color
                        end
                        -- outline stroke color & toggle
                        local border = box:FindFirstChild("Border")
                        if border then
                            local uiStroke = border:FindFirstChildOfClass("UIStroke")
                            if uiStroke then
                                uiStroke.Color = color
                                uiStroke.Enabled = ESP.outline
                                uiStroke.Thickness = STROKE_THICKNESS
                            end
                        end
                    else
                        box.Visible = false
                    end
                else
                    if boxes[name] then boxes[name]:Destroy(); boxes[name] = nil end
                end

                -- NAMES + DISTANCE (locked to top center of box)
                if ESP.names then
                    if not nameLabels[name] then nameLabels[name] = createNameLabel(name) end
                    local lbl = nameLabels[name]
                    local anchorPos = smoothedPos[name]
                    if anchorPos then
                        -- place name centered on box top, distance to the right
                        local text = name
                        local distText = ""
                        if ESP.distance and root then
                            local d = math.floor((hrp.Position - root.Position).Magnitude)
                            distText = (" %dm"):format(d)
                        end
                        lbl.Text = text
                        -- measure label size after text set (AbsoluteSize may be 0 until parent has rendered; we'll approximate by width constant fallback)
                        local width = lbl.AbsoluteSize.X
                        if width == 0 then width = 140 end
                        lbl.Position = UDim2.new(0, math.floor(anchorPos.X - (width/2)), 0, math.floor(anchorPos.Y - 24))
                        lbl.TextColor3 = color
                        lbl.Visible = true

                        -- distance label next to name
                        if ESP.distance then
                            if not distLabels[name] then distLabels[name] = createDistLabel(name) end
                            local dl = distLabels[name]
                            dl.Text = distText
                            local dwidth = dl.AbsoluteSize.X
                            if dwidth == 0 then dwidth = 48 end
                            -- place right after name (with a 4px gap)
                            dl.Position = UDim2.new(0, math.floor(anchorPos.X + (width/2) + 4), 0, math.floor(anchorPos.Y - 24))
                            dl.TextColor3 = color
                            dl.Visible = true
                        else
                            if distLabels[name] then distLabels[name].Visible = false end
                        end
                    else
                        if nameLabels[name] then nameLabels[name].Visible = false end
                        if distLabels[name] then distLabels[name].Visible = false end
                    end
                else
                    if nameLabels[name] then nameLabels[name]:Destroy(); nameLabels[name] = nil end
                    if distLabels[name] then distLabels[name]:Destroy(); distLabels[name] = nil end
                end

                -- HEALTH (vertical bar 3px gap to the right of the box)
                if ESP.health then
                    if not healthBars[name] then healthBars[name] = createHealthBar(name) end
                    local hb = healthBars[name]
                    if boxes[name] and boxes[name].Visible then
                        -- position to the right of the box with healthGapPx
                        local boxPos = boxes[name].AbsolutePosition
                        local boxSize = boxes[name].AbsoluteSize
                        -- ensure AbsoluteSize is valid (might be 0 if not yet rendered)
                        local bpX = boxPos.X; local bpY = boxPos.Y; local bw = boxSize.X; local bh = boxSize.Y
                        if bw == 0 or bh == 0 then
                            hb.Visible = false
                        else
                            local px = math.floor(bpX + bw + DEFAULTS.healthGapPx)
                            local py = math.floor(bpY)
                            hb.Size = UDim2.new(0, DEFAULTS.healthBarWidth, 0, bh)
                            hb.Position = UDim2.new(0, px, 0, py)
                            local fill = hb:FindFirstChild("Fill")
                            local pct = getHealthPercent(otherChar) or 1
                            if fill then
                                fill.Size = UDim2.new(1,0,pct,0)
                                fill.Position = UDim2.new(0,0,1-pct,0)
                                fill.BackgroundColor3 = color
                            end
                            hb.Visible = true
                        end
                    else
                        hb.Visible = false
                    end
                else
                    if healthBars[name] then healthBars[name]:Destroy(); healthBars[name] = nil end
                end

                -- TRACERS (smooth from bottom-center to bottom-of-box)
                if ESP.tracers then
                    if not tracers[name] then tracers[name] = createTracer(name) end
                    local tr = tracers[name]
                    -- compute smoothed bottom-center of box (use smoothedTracerEnd)
                    local endPos = smoothedTracerEnd[name] or targetBot
                    if endPos and (endPos.X ~= 0 or endPos.Y ~= 0) then
                        -- origin bottom center
                        local origin = Vector2.new(camera.ViewportSize.X * 0.5, camera.ViewportSize.Y - DEFAULTS.tracerOriginOffset)
                        local delta = endPos - origin
                        local dist = math.max(2, delta.Magnitude)
                        local angle = math.deg(math.atan2(delta.Y, delta.X))
                        tr.Size = UDim2.new(0, math.floor(dist), 0, DEFAULTS.tracerThickness)
                        tr.Position = UDim2.new(0, origin.X, 0, origin.Y)
                        tr.Rotation = angle
                        tr.AnchorPoint = Vector2.new(0, 0.5)
                        tr.BackgroundColor3 = color
                        tr.Visible = true
                    else
                        tr.Visible = false
                    end
                else
                    if tracers[name] and tracers[name].Parent then tracers[name].Visible = false end
                end

            else
                -- non-R6 or no char: cleanup
                if boxes[other.Name] or nameLabels[other.Name] or distLabels[other.Name] or healthBars[other.Name] or tracers[other.Name] then
                    -- remove them all
                    if boxes[other.Name] then boxes[other.Name]:Destroy(); boxes[other.Name] = nil end
                    if nameLabels[other.Name] then nameLabels[other.Name]:Destroy(); nameLabels[other.Name] = nil end
                    if distLabels[other.Name] then distLabels[other.Name]:Destroy(); distLabels[other.Name] = nil end
                    if healthBars[other.Name] then healthBars[other.Name]:Destroy(); healthBars[other.Name] = nil end
                    if tracers[other.Name] then tracers[other.Name]:Destroy(); tracers[other.Name] = nil end
                    smoothedPos[other.Name] = nil
                    smoothedTracerEnd[other.Name] = nil
                end
            end
        end
    end

    -- Backstab detection: prefer workspace.Players.Killers, else other players
    local killersToCheck = {}
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, nm in ipairs(killerNames) do
            local k = killersFolder:FindFirstChild(nm)
            if k and k:FindFirstChild("HumanoidRootPart") then table.insert(killersToCheck, k) end
        end
    end
    if #killersToCheck == 0 then
        for _, other in ipairs(Players:GetPlayers()) do
            if other ~= lp and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(killersToCheck, other.Character)
            end
        end
    end

    for _, kobj in ipairs(killersToCheck) do
        local kHRP = kobj and kobj:FindFirstChild("HumanoidRootPart")
        if kHRP then
            if enabled and not cooldown and isBehindTarget(hrp, kHRP) and kobj ~= lastTarget then
                cooldown = true
                lastTarget = kobj

                tweenBehindAndStab(kHRP, DEFAULTS.tweenDuration)

                -- reset cooldown after leaving range
                task.delay(2, function()
                    RunService.Heartbeat:Wait()
                    while isBehindTarget(hrp, kHRP) do RunService.Heartbeat:Wait() end
                    lastTarget = nil
                    cooldown = false
                end)

                break
            end
        end
    end
end)

-- Persist GUI text & visuals on start
for _,info in ipairs(rightButtons) do
    local key = info.key
    if rightBtnsInstances[key] then
        rightBtnsInstances[key].Text = info.label(ESP[key])
        updateBtnVisual(rightBtnsInstances[key], ESP[key])
    end
end
updateBtnVisual(backstabBtn, enabled)
rangeLabel.Text = ("range: %.1f"):format(range)
modeBtn.Text = ("mode:%s"):format(mode)

getgenv().ESP_SETTINGS = ESP

-- keep original isBehindTarget logic
function isBehindTarget(hrp, targetHRP)
    local dist = (hrp.Position - targetHRP.Position).Magnitude
    if dist > range then return false end
    if mode == "around" then return true end
    local direction = -targetHRP.CFrame.LookVector
    local toPlayer = (hrp.Position - targetHRP.Position)
    return toPlayer:Dot(direction) > 0.5
end

-- End of script
